/*
 * S2E Selective Symbolic Execution Framework
 *
 * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Currently maintained by:
 *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
 *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
 *
 * All contributors are listed in S2E-AUTHORS file.
 *
 */

#ifndef S2E_PLUGINS_EXPLOIT_H
#define S2E_PLUGINS_EXPLOIT_H

#include <s2e/Plugin.h>
#include <s2e/Plugins/CorePlugin.h>
#include <s2e/S2EExecutionState.h>

#define NOP_VALUE   0x90

#define INTERVAL_NOP            0
#define INTERVAL_UNREACHABLE    1
#define INTERVAL_UNINSERTABLE   2

namespace s2e {
namespace plugins {

struct StartAddrProfile {
                StartAddrProfile(uint32_t a, uint32_t m, uint32_t M) {
                    addr = a;
                    minNop = m;
                    maxNop = M;
                }
    uint32_t    addr;
    uint32_t    minNop;
    uint32_t    maxNop;
};

class Exploit;
class ShellcodeAddrManager {
private:
    class AddrInterval;

    struct IntervalAddrComp {
        bool operator() (const AddrInterval *lhs, const AddrInterval *rhs) const;
    };

    struct IntervalNopComp {
        bool operator() (const AddrInterval *lhs, const AddrInterval *rhs) const;
    };

    /* The set of AddrInterval sorted by address */
    typedef std::multiset<AddrInterval*, IntervalAddrComp> IntervalAddrSet;

    /* The set of AddrInterval sorted by nop length */
    typedef std::multiset<AddrInterval*, IntervalNopComp> IntervalNopSet;

    typedef IntervalAddrSet::iterator AddrSetIter;
    typedef IntervalNopSet::iterator NopSetIter;

    typedef std::pair<AddrInterval*, AddrInterval*> IntervalPair;

    struct AddrInterval {
        AddrInterval(uint32_t a, uint32_t l, uint32_t n, uint32_t ur, uint32_t ui) {
            assert(l && "Try to make a zero length interval!");
            addr = a;
            length = l;
            ivLen[INTERVAL_NOP] = n;
            ivLen[INTERVAL_UNREACHABLE] = ur;
            ivLen[INTERVAL_UNINSERTABLE] = ui;
        }

        uint32_t end() const {
            return addr+length-1;
        }

        uint32_t intervalLen(uint32_t interval) const {
            return ivLen[interval];
        }

        void setIntervalLen(uint32_t interval, uint32_t value) {
            ivLen[interval] = value;
        }

        uint32_t intervalLenAt(uint32_t interval, uint32_t index) const {
            int res = ivLen[interval] - (length-index-1);
            return res >= 0 ? res : 0;
        }

        uint32_t intervalStart(uint32_t interval) const {
            if(ivLen[interval] != 0) {
                return addr+length-ivLen[interval];
            }
            else {
                return 0;
            }
        }

        int maxNopLen() const {
            if(intervalLen(INTERVAL_UNINSERTABLE) >= length) {
                return -1;
            }
            else {
                uint32_t index = length-intervalLen(INTERVAL_UNINSERTABLE)-1;
                uint32_t urLen = intervalLenAt(INTERVAL_UNREACHABLE, index);
                uint32_t nLen = intervalLenAt(INTERVAL_NOP, index);
                if(urLen != 0 && (nLen <= urLen)) {
                    return -1;
                }
                else {
                    return (nLen==0?0:nLen-1);
                }
            }
        }

        uint32_t    addr;
        uint32_t    length;
        uint32_t    ivLen[3];

        AddrSetIter addrIter;
        NopSetIter  nopIter;
    };

public:
                ShellcodeAddrManager(S2EExecutionState *s, Exploit *e);
               ~ShellcodeAddrManager();
    void        addSymbolicRange(uint32_t start, uint32_t end);
    void        updateUninsertable(uint32_t start, uint32_t end);
    void        updateUnreachable(uint32_t start, uint32_t end);

    /* Not implemented yet */
    uint32_t    getAddrWithMaxNOP();

    /* Get the "possibly" best shellcode address, that is, the address where
       we "can" insert shellcode, and we "may" insert longest NOP sled. But the 
       number of NOPs we can insert is not ensured, this function is just used 
       as a selection heuristic.
     */
    StartAddrProfile    getAddrWithPossiblyMoreNOP();

private:
    void        updateBadInterval(uint32_t start, uint32_t end, uint32_t interval);
    void        insertInterval(uint32_t addr, uint32_t length, uint32_t nopLen, uint32_t unreachableLen, uint32_t uninsertableLen);
    AddrInterval*   newInterval(uint32_t a, uint32_t l, uint32_t n, uint32_t ur, uint32_t ui);
    IntervalPair    splitInterval(AddrInterval *interval, uint32_t mid);
    void        unassociate(AddrInterval *interval);
    void        updateInterval(AddrInterval *interval);
    void        updateIntervalInternal(AddrInterval *interval);
    void        checkAndDelete(AddrInterval *prev);
    void        checkMergeAndAddInterval(AddrInterval *prev, AddrInterval *curr);
    void        addInterval(AddrInterval *interval);
    void        delInterval(AddrInterval *interval);
    AddrInterval*   findPrev(uint32_t addr);
    AddrInterval*   findContains(uint32_t addr);
    AddrInterval*   findContainsOrLater(uint32_t addr);
    AddrInterval*   findLowerConnectedOrContains(uint32_t addr);
    AddrInterval*   findHigherConnectedOrContains(uint32_t addr);
    AddrInterval*   findHigherConnectedOrBefore(uint32_t addr);
    bool        canBeValue(uint32_t addr, uint8_t value);
    bool        canPutShellcodeAndMinNop(uint32_t shellcodeStart, uint32_t minNop);

    S2EExecutionState *state;
    Exploit *exploit;
    IntervalAddrSet addrSet;
    IntervalNopSet  nopSet;
    bool calledUpdate;
    std::vector<uint8_t> shellcodeVector;
};

#define FMT_OFFSET_WORD_SIZE    4   // The displacement of accessed address of %1$x and %2$x
#define MAX_FMT_LENGTH          128
class FMTGenerator {
public:
    static char* genFmt(uint32_t targetAddr, uint32_t targetValue, 
                    uint32_t dollarOffset, uint32_t wordOffset, uint32_t fmtOffset);
private:
    static uint8_t* itoa(uint8_t *ptr, uint32_t num);
    static uint8_t* cat(uint8_t *ptr, const char *str);
    static uint8_t* addLength(uint8_t *ptr, uint32_t len);
};

struct FMTProfile {
    uint32_t targetAddr;
    uint32_t targetValue;
    uint32_t dollarOffset;
    uint32_t wordOffset;
    uint32_t shellcodeAndNopStart;
    uint32_t shellcodeEnd;
    uint32_t stringStart;
    uint32_t stringEnd;
    uint32_t fmtStart;
    uint32_t fmtEnd;
};

class Exploit : public Plugin {
    S2E_PLUGIN

public:
    struct MemBlock {
        MemBlock(uint32_t a, uint32_t s) {addr = a; size = s;}
        uint32_t addr;
        uint32_t size;
    };

    struct MemBlockAddrComp {
        bool operator() (const MemBlock& lhs, const MemBlock& rhs) const {return lhs.addr < rhs.addr;}
    };
    
    struct MemBlockSizeComp {
        bool operator() (const MemBlock& lhs, const MemBlock& rhs) const {return lhs.size > rhs.size;}
    };

    typedef std::multiset<MemBlock, MemBlockAddrComp> BlockAddrSet;
    typedef std::multiset<MemBlock, MemBlockAddrComp>::iterator BlockAddrSetIter;

    typedef std::multiset<MemBlock, MemBlockSizeComp> BlockSizeSet;
    typedef std::multiset<MemBlock, MemBlockSizeComp>::iterator BlockSizeSetIter;

    struct RedirectionContext {
        RedirectionContext(uint32_t rt, klee::ref<klee::Expr> eip, klee::ref<klee::Expr> esp, klee::ref<klee::Expr> con) {
            redirectionTimes = rt;
            eipValue = eip;
            espValue = esp;
            newConstraint = con;
        }
        uint32_t                redirectionTimes;
        klee::ref<klee::Expr>   eipValue;
        klee::ref<klee::Expr>   espValue;
        klee::ref<klee::Expr>   newConstraint;
    };
    
            Exploit(S2E* s2e): Plugin(s2e) {}

    void            initialize();
    std::vector<unsigned char> getShellcode(std::string shellcode);
    void            onCorruptReg(S2EExecutionState *state, klee::ref<klee::Expr> value, klee::ref<klee::Expr> hostAddr);
    void            onCorruptPtr(S2EExecutionState *state, klee::ref<klee::Expr> addrExpr, klee::ref<klee::Expr> valueExpr);
    void            onCorruptFmt(S2EExecutionState *state, uint32_t fmt, uint32_t dollarOffset, uint32_t wordOffset);
    void            onSetInputRange(S2EExecutionState *state, uint32_t addr, uint32_t size);
    void            onSetSymbolicAddr(S2EExecutionState *state, uint32_t addr, const char *name);
    void            onDumpSymbolicBlocks(S2EExecutionState *state);

    void            getRedirectionPriority(S2EExecutionState *state, uint32_t *redirections);
    bool            tryRedirectionRecursive(S2EExecutionState *state, RedirectionContext& ctx);
    bool            insertShellcodeWithEIPRedirection(S2EExecutionState *state, klee::ref<klee::Expr> eipValue);
    bool            insertShellcode(S2EExecutionState *state, klee::ref<klee::Expr> symEIPValue);
    int             testShellcode(S2EExecutionState *state, uint32_t shellCodeStartAddr, klee::ref<klee::Expr> symEIPValue, uint32_t symBufStartAddr);
    int             testAndGetNopSize(S2EExecutionState *state, uint32_t start, uint32_t end, klee::ref<klee::Expr> symEIPValue, klee::ref<klee::Expr> shellCodeConstraint);
    void            addConstraints(S2EExecutionState *state, klee::ref<klee::Expr> tainted_ptr, uint32_t shellcodeStartAddr, int nop_size);
    int             getMaxNopAndAddr(S2EExecutionState *state, klee::ref<klee::Expr> symEIPValue, const char where[], uint32_t *r_shellCodeStart);
    void            genExploit(S2EExecutionState *state, const char *filename);
    void            enterExploitGenStage(S2EExecutionState *state);
    void            leaveExploitGenStage(S2EExecutionState *state);

    klee::ref<klee::Expr>   getShellcodeConstraint(S2EExecutionState *state, uint32_t shellcodeStart);
    klee::ref<klee::Expr>   getNopConstraint(S2EExecutionState *state, uint32_t shellcodeStart, uint32_t nopLen);
    klee::ref<klee::Expr>   getStringConstraint(S2EExecutionState *state, uint32_t addr, uint8_t *str);
    klee::ref<klee::Expr>   getFmtReserveConstraint(S2EExecutionState *state, uint32_t reserveStart, uint32_t reserveEnd);
    klee::ref<klee::Expr>   getFmtFinishingConstraint(S2EExecutionState *state, FMTProfile *pf);
    bool            checkAndAddFmtConstraint(S2EExecutionState *state, FMTProfile *pf);
    bool            canBeFmtChar(S2EExecutionState *state, uint32_t addr);

    BlockSizeSet    searchSymbolicArray(S2EExecutionState *state, uint64_t start, uint64_t end);
    BlockSizeSet    searchExceptFutureStack(S2EExecutionState *state);
    BlockAddrSet    searchFmtArray(S2EExecutionState *state, uint32_t start, uint32_t end);
    BlockAddrSet    searchMappedBlock(S2EExecutionState *state);

    void            addBlockRange(BlockAddrSet &addrSet, uint32_t start, uint32_t end);
    void            deleteBlockRange(BlockAddrSet &addrSet, uint32_t start, uint32_t end);
    bool            isOverlap(BlockAddrSet &addrSet, uint32_t start, uint32_t end);
    uint32_t        findEnoughLenBefore(BlockAddrSet &addrSet, uint32_t addr, uint32_t len);

    uint32_t        findFeasibleRet(S2EExecutionState *state, klee::ref<klee::Expr> ptr, uint32_t min, uint32_t max);
    uint32_t        findFeasibleJmp(S2EExecutionState *state, klee::ref<klee::Expr> ptr, uint32_t min, uint32_t max);
    void            printFeasibleSymbolic(S2EExecutionState *state, klee::ref<klee::Expr> expr, uint32_t min, uint32_t max, BlockAddrSet &symBlocks);
    void            printPossibleByteCountInRange(S2EExecutionState *state, uint32_t start, uint32_t end);
    uint32_t        getPossibleByteCount(S2EExecutionState *state, klee::ref<klee::Expr> expr, uint8_t min, uint8_t max);

    uint32_t        findMaximum(S2EExecutionState *state, klee::ref<klee::Expr> expr);
    uint32_t        findMinimum(S2EExecutionState *state, klee::ref<klee::Expr> expr);
    bool            mayBeTrue(S2EExecutionState *state, klee::ref<klee::Expr> expr);
    bool            mustBeTrue(S2EExecutionState *state, klee::ref<klee::Expr> expr);

    std::string m_shellcode;
    std::vector<uint8_t> m_shellcodeVector;
private:
    typedef std::pair<std::string, std::vector<unsigned char> > VarValuePair;
    typedef std::vector<VarValuePair> ConcreteInputs;
    typedef std::map<uint32_t, std::string> OffsetSymMap;

    BlockAddrSet m_symAddrSet;  /* Symbolic blocks sorted by address */
    BlockSizeSet m_symSizeSet;  /* Symbolic blocks sorted by size */
    BlockAddrSet m_jmpAddrSet;
    BlockAddrSet m_mappedAddrSet;

    uint32_t m_inputAddr;
    uint32_t m_inputSize;
    OffsetSymMap m_offsetSymMap;

    int64_t m_prevNopSize;

    uint32_t m_GOTAddress;
    int m_exploitType;

    S2EExecutionState *m_currEGState;
    bool m_currEGStateIsConcolicMode;
};

} // namespace plugins
} // namespace s2e

#endif // S2E_PLUGINS_EXPLOIT_H
